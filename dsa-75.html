<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Deep Dive: Set 1 (ELI5 Edition)</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-primary: #2d3748;
            --accent: #6366f1; /* Indigo */
            --code-bg: #1e1e1e;
            --analogy-bg: #e0e7ff; /* Light Indigo */
            --pattern-bg: #d1fae5; /* Light Green */
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.7;
            max-width: 850px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        h1 { text-align: center; color: var(--accent); margin-bottom: 40px; }
        .problem-card {
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-bottom: 50px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }
        .header {
            background: var(--accent);
            color: white;
            padding: 15px 25px;
            font-size: 1.25rem;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }
        .difficulty {
            background: rgba(255,255,255,0.2);
            padding: 2px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            text-transform: uppercase;
        }
        .content { padding: 25px; }
        
        /* The Thinking Sections */
        .section-title {
            font-weight: 800;
            color: #4a5568;
            margin-top: 20px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.85rem;
        }
        
        .eli5-box {
            background-color: var(--analogy-bg);
            border-left: 5px solid var(--accent);
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 20px;
        }
        .pattern-box {
            background-color: var(--pattern-bg);
            border-left: 5px solid #10b981;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 20px;
        }

        .visual-step {
            font-family: monospace;
            background: #f1f5f9;
            padding: 10px;
            border-radius: 4px;
            margin: 5px 0;
            border: 1px dashed #cbd5e1;
        }

        /* Code Styling */
        pre {
            background-color: var(--code-bg);
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9rem;
        }
        .comment { color: #6a9955; font-style: italic; }
        .keyword { color: #c586c0; }
        .func { color: #dcdcaa; }
        .var { color: #9cdcfe; }
    </style>
</head>
<body>

    <h1>Deep Dive: The Thinking Process (1-5)</h1>

    <div class="problem-card">
        <div class="header">
            1. Two Sum
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Puzzle Piece" Analogy</div>
            <div class="eli5-box">
                <p>Imagine you have a jigsaw puzzle piece in your hand (this is the number you are holding right now, let's say <strong>2</strong>).</p>
                <p>You know the whole picture must add up to <strong>9</strong>.</p>
                <p><strong>The Wrong Way:</strong> You run around the room holding your "2" and check it against every single other piece on the floor. Then you pick up the next piece and do it again. (Too slow!).</p>
                <p><strong>The Smart Way:</strong> You pick up "2". You know you need a "7" to win. You yell out: <em>"HAS ANYONE SEEN A 7?"</em>. If your friend (the HashMap) says "Yes, I saw a 7 at index 0!", you win immediately. If not, you give your "2" to your friend to hold, and pick up the next piece.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: The Complement Search (Hashing)</strong><br>
                Instead of focusing on <em>"What adds up to Target?"</em> (which requires two loops), focus on <em>"What am I missing?"</em>.<br>
                Math: <code>Target - CurrentNumber = NeededNumber</code>.<br>
                We use a Map to store what we have visited so we can look it up in O(1) time.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">twoSum</span>(<span class="var">nums</span>: number[], <span class="var">target</span>: number): number[] {
    <span class="comment">// The "Friend" who remembers numbers we've seen</span>
    <span class="keyword">const</span> seenMap = <span class="keyword">new</span> Map&lt;number, number&gt;();

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < nums.length; i++) {
        <span class="keyword">const</span> current = nums[i];
        <span class="keyword">const</span> needed = target - current;

        <span class="comment">// "Hey friend, do you have the 'needed' number?"</span>
        <span class="keyword">if</span> (seenMap.has(needed)) {
            <span class="keyword">return</span> [seenMap.get(needed)!, i];
        }

        <span class="comment">// If not, give current number to friend and keep moving</span>
        seenMap.set(current, i);
    }
    <span class="keyword">return</span> [];
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            2. Best Time to Buy & Sell Stock
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Time Traveler" Analogy</div>
            <div class="eli5-box">
                <p>Imagine you are walking through time, day by day. You can't see the future, but you can remember the past.</p>
                <p>You only need to remember ONE thing to get rich: <strong>"What was the absolute cheapest price I have seen SO FAR?"</strong></p>
                <p>Every day, you ask yourself two questions:</p>
                <ol>
                    <li>Is today's price cheaper than my memory? -> <em>Update memory.</em></li>
                    <li>If I sold today (using my cheap memory price), how much would I make? -> <em>Is this the most money I've seen yet?</em></li>
                </ol>
            </div>
            

[Image of stock market graph sliding window]


            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Single Pass (Greedy Min)</strong><br>
                You don't need to compare every day to every other day (Nested Loops). You only care about the gap between <code>Current Price</code> and <code>Minimum Price So Far</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">maxProfit</span>(<span class="var">prices</span>: number[]): number {
    <span class="keyword">let</span> minPrice = Infinity; <span class="comment">// Start with a very high number</span>
    <span class="keyword">let</span> maxProfit = 0;

    <span class="keyword">for</span> (<span class="keyword">const</span> price <span class="keyword">of</span> prices) {
        <span class="keyword">if</span> (price < minPrice) {
            <span class="comment">// Found a new lowest valley to buy at</span>
            minPrice = price;
        } <span class="keyword">else</span> {
            <span class="comment">// Calculate profit if we sold today</span>
            <span class="keyword">const</span> profit = price - minPrice;
            <span class="keyword">if</span> (profit > maxProfit) {
                maxProfit = profit;
            }
        }
    }
    <span class="keyword">return</span> maxProfit;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            3. Contains Duplicate
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Magic Box" Analogy</div>
            <div class="eli5-box">
                <p>Imagine you have a Magic Box (this is a <strong>Set</strong>).</p>
                <p>The Magic Box has a rule: <strong>It refuses to hold the same toy twice.</strong></p>
                <p>You take numbers from the list one by one and try to shove them into the box. If you try to put a "5" in, and the box screams <em>"I ALREADY HAVE A 5!"</em>... boom! You found a duplicate.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Hash Set (Uniqueness)</strong><br>
                A Set in programming is a data structure optimized for checking "Have I seen this?". Adding to a set is O(1). Checking a set is O(1).
                <br><em>Alternative thought:</em> If the length of the list is 10, but the size of the Set is 9... something was repeated.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">containsDuplicate</span>(<span class="var">nums</span>: number[]): boolean {
    <span class="comment">// Try to make a set out of the array</span>
    <span class="keyword">const</span> uniqueSet = <span class="keyword">new</span> Set(nums);
    
    <span class="comment">// If the Set is smaller than the Array, duplicates were removed</span>
    <span class="keyword">return</span> uniqueSet.size !== nums.length;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            4. Product of Array Except Self
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Blindfolded House" Analogy</div>
            <div class="eli5-box">
                <p>Imagine a street of houses. You live in one house. You want to know how much money everyone else on the street has combined (multiplied), <strong>but you are not allowed to look at your own money</strong> (and you can't use division to cheat).</p>
                <p>How do you do it?</p>
                <ol>
                    <li><strong>Look Left:</strong> Someone walks from the start of the street, accumulating the product, and drops a note at your door saying "Here is the product of everyone to your left."</li>
                    <li><strong>Look Right:</strong> Someone walks from the end of the street backwards, and drops a note saying "Here is the product of everyone to your right."</li>
                </ol>
                <p>You pick up both notes, multiply them, and that's your answer!</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Prefix & Suffix (Pre-computation)</strong><br>
                Current Index = (Product of all Left) * (Product of all Right).<br>
                We do two passes. 
                1. Pass Left->Right to calculate Prefix products.
                2. Pass Right->Left to multiply by Suffix products.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">productExceptSelf</span>(<span class="var">nums</span>: number[]): number[] {
    <span class="keyword">const</span> result = <span class="keyword">new</span> Array(nums.length).fill(1);
    
    <span class="comment">// Pass 1: "The Note from the Left"</span>
    <span class="keyword">let</span> leftProduct = 1;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < nums.length; i++) {
        result[i] = leftProduct; <span class="comment">// Store what's to the left</span>
        leftProduct = leftProduct * nums[i]; <span class="comment">// Update for next house</span>
    }

    <span class="comment">// Pass 2: "The Note from the Right"</span>
    <span class="keyword">let</span> rightProduct = 1;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - 1; i >= 0; i--) {
        result[i] = result[i] * rightProduct; <span class="comment">// Multiply Left * Right</span>
        rightProduct = rightProduct * nums[i]; <span class="comment">// Update for next house</span>
    }

    <span class="keyword">return</span> result;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            5. Maximum Subarray (Kadane's Algo)
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Heavy Backpack" Analogy</div>
            <div class="eli5-box">
                <p>You are walking down a road picking up gold coins (positive numbers) and heavy rocks (negative numbers). You put them in your backpack.</p>
                <p>Your goal: Have the heaviest backpack possible at any point.</p>
                <p>However, sometimes you pick up so many rocks that your backpack basically has "negative value" (it's a burden). </p>
                <p><strong>The Rule:</strong> If your backpack's total value drops below zero, <strong>dump the whole bag out</strong>. It's useless. Start fresh from the next step with an empty bag.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Kadane's Algorithm (Dynamic Programming)</strong><br>
                The question is: <em>"Should I extend the previous subarray, or start a new one?"</em><br>
                If the `currentSum` becomes negative, it contributes nothing positive to the future. Reset `currentSum` to 0.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">maxSubArray</span>(<span class="var">nums</span>: number[]): number {
    <span class="keyword">let</span> maxSoFar = nums[0];
    <span class="keyword">let</span> currentBag = 0;

    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> nums) {
        <span class="keyword">if</span> (currentBag < 0) {
            currentBag = 0; <span class="comment">// Dump the bag, it's a burden</span>
        }
        
        currentBag += n; <span class="comment">// Add current item</span>
        
        <span class="comment">// Did this maximize our record?</span>
        maxSoFar = Math.max(maxSoFar, currentBag);
    }
    <span class="keyword">return</span> maxSoFar;
}</pre>
        </div>
    </div>
<div class="problem-card">
        <div class="header">
            6. Maximum Product Subarray
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Evil Twin" Analogy</div>
            <div class="eli5-box">
                <p>Remember the backpack analogy from Problem 5? This is similar, but with a twist: <strong>Negative numbers are tricky magic.</strong></p>
                <p>A negative number (like -5) ruins a positive streak. BUT, if you hit <em>another</em> negative number later (like -2), suddenly (-5 * -2) becomes a massive <strong>+10</strong>.</p>
                <p><strong>The Strategy:</strong> You can't just track the "Best" value. You must also track the "Worst" (most negative) value. Why? Because the "Worst" villain might meet another negative number and instantly become the "Best" hero.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Dynamic Programming (Dual State)</strong><br>
                Keep two running variables: <code>curMax</code> and <code>curMin</code>.<br>
                When you see a negative number, swap Max and Min (because the biggest number * negative becomes the smallest, and vice versa).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">maxProduct</span>(<span class="var">nums</span>: number[]): number {
    <span class="keyword">let</span> res = Math.max(...nums);
    <span class="keyword">let</span> curMin = 1;
    <span class="keyword">let</span> curMax = 1;

    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> nums) {
        <span class="keyword">if</span> (n === 0) {
            <span class="comment">// 0 resets the streak. Start fresh.</span>
            curMin = 1;
            curMax = 1;
            <span class="keyword">continue</span>;
        }

        <span class="keyword">const</span> tmp = curMax * n;
        <span class="comment">// Track both potential max and min</span>
        curMax = Math.max(n * curMax, n * curMin, n);
        curMin = Math.min(tmp, n * curMin, n);
        
        res = Math.max(res, curMax);
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            7. Find Minimum in Rotated Sorted Array
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Broken Dictionary" Analogy</div>
            <div class="eli5-box">
                <p>Imagine a dictionary (sorted A-Z) that someone cut in half and pasted the second half at the beginning.</p>
                <p>It looks like this: <code>[P, Q, R, ..., Z, A, B, C]</code>.</p>
                <p>You want to find 'A' (the start/minimum). You open the book in the <strong>middle</strong>.</p>
                <ul>
                    <li>If the right side looks normal (Middle < End), then the small numbers are to your <strong>Left</strong>.</li>
                    <li>If the right side looks broken (Middle > End), then the drop-off (the cliff) is to your <strong>Right</strong>. The 'A' is hiding in the chaos.</li>
                </ul>
            </div>
            

[Image of binary search on rotated array]


            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Binary Search (Modified)</strong><br>
                Standard Binary Search, but instead of looking for a target, we look for the "Cliff" (where the numbers drop).<br>
                If <code>nums[mid] > nums[right]</code>, we know the rotation pivot is in the right half.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">findMin</span>(<span class="var">nums</span>: number[]): number {
    <span class="keyword">let</span> left = 0;
    <span class="keyword">let</span> right = nums.length - 1;

    <span class="keyword">while</span> (left < right) {
        <span class="keyword">const</span> mid = Math.floor((left + right) / 2);
        
        <span class="comment">// If Middle is huge compared to Right, the dip is to the right</span>
        <span class="keyword">if</span> (nums[mid] > nums[right]) {
            left = mid + 1;
        } <span class="keyword">else</span> {
            <span class="comment">// The dip is to the left (or we are sitting on it)</span>
            right = mid;
        }
    }
    <span class="keyword">return</span> nums[left];
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            8. Search in Rotated Sorted Array
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Safe Zone" Analogy</div>
            <div class="eli5-box">
                <p>Same "Broken Dictionary" as above. But now you are looking for a specific letter, say 'K'.</p>
                <p>When you cut the array in half, <strong>one side will always be perfectly sorted (Safe Zone)</strong>, and the other side will be the broken mess.</p>
                <p>1. Identify the Safe Zone.<br>
                2. Ask: "Is 'K' inside this Safe Zone range?"<br>
                3. If yes, go there. If no, go to the messy side.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Binary Search (Zone Check)</strong><br>
                Check <code>if (nums[left] <= nums[mid])</code> to see if the Left side is the sorted one. Then do a simple range check <code>(target >= left && target < mid)</code> to see if we should go that way.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">search</span>(<span class="var">nums</span>: number[], <span class="var">target</span>: number): number {
    <span class="keyword">let</span> left = 0, right = nums.length - 1;

    <span class="keyword">while</span> (left <= right) {
        <span class="keyword">const</span> mid = Math.floor((left + right) / 2);
        <span class="keyword">if</span> (nums[mid] === target) <span class="keyword">return</span> mid;

        <span class="comment">// Check if Left side is sorted</span>
        <span class="keyword">if</span> (nums[left] <= nums[mid]) {
            <span class="comment">// Is target in this sorted range?</span>
            <span class="keyword">if</span> (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } <span class="keyword">else</span> {
                left = mid + 1;
            }
        } 
        <span class="comment">// Otherwise, Right side must be sorted</span>
        <span class="keyword">else</span> {
            <span class="comment">// Is target in this sorted range?</span>
            <span class="keyword">if</span> (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
            } <span class="keyword">else</span> {
                right = mid - 1;
            }
        }
    }
    <span class="keyword">return</span> -1;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            9. 3Sum
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Fix One, Move Two" Analogy</div>
            <div class="eli5-box">
                <p>You want 3 numbers to add up to 0.</p>
                <p>Trying every combination of 3 is chaos. Instead, imagine a party line.</p>
                <p>1. <strong>Sort the people by height</strong> (Sorting is key!).<br>
                2. You pick the first person and say "FREEZE! You stay here."<br>
                3. Now you just need 2 other people to balance out that first person.<br>
                4. Since everyone is sorted, you can use the "Two Pointer" trick from Problem 1: Have one person from the far left (small) and one from the far right (big) walk toward each other until they fit.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Sorting + Two Pointers</strong><br>
                Sort first O(N log N). Loop through the array (variable <code>i</code>). For each <code>i</code>, solve the "Two Sum" problem on the remaining array using Left and Right pointers.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">threeSum</span>(<span class="var">nums</span>: number[]): number[][] {
    nums.sort((a, b) => a - b); <span class="comment">// Must sort first</span>
    <span class="keyword">const</span> res: number[][] = [];

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < nums.length; i++) {
        <span class="comment">// Avoid duplicates for the first number</span>
        <span class="keyword">if</span> (i > 0 && nums[i] === nums[i-1]) <span class="keyword">continue</span>;

        <span class="keyword">let</span> left = i + 1;
        <span class="keyword">let</span> right = nums.length - 1;

        <span class="keyword">while</span> (left < right) {
            <span class="keyword">const</span> sum = nums[i] + nums[left] + nums[right];
            
            <span class="keyword">if</span> (sum > 0) {
                right--; <span class="comment">// Too big, decrease right</span>
            } <span class="keyword">else</span> <span class="keyword">if</span> (sum < 0) {
                left++;  <span class="comment">// Too small, increase left</span>
            } <span class="keyword">else</span> {
                res.push([nums[i], nums[left], nums[right]]);
                left++;
                <span class="comment">// Skip duplicates for the second number</span>
                <span class="keyword">while</span> (nums[left] === nums[left-1] && left < right) left++;
            }
        }
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            10. Container With Most Water
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Leaky Bucket" Analogy</div>
            <div class="eli5-box">
                <p>You have two vertical walls holding water. The water level is always determined by the <strong>shorter</strong> wall (otherwise it spills over).</p>
                <p>You want the biggest area (Width Ã— Height).</p>
                <p><strong>The Move:</strong> You have a Left wall and a Right wall. Who should move? <br>
                If you move the <em>Tall</em> wall, your height is still limited by the Short wall, but your width got smaller. You <strong>lose</strong>. <br>
                You MUST move the <em>Short</em> wall. It's your only hope of finding a taller wall to hold more water.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Greedy Two Pointers</strong><br>
                Start pointers at edges (Max Width). Calculate Area. Always shift the pointer that points to the smaller height.</p>
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">maxArea</span>(<span class="var">height</span>: number[]): number {
    <span class="keyword">let</span> left = 0;
    <span class="keyword">let</span> right = height.length - 1;
    <span class="keyword">let</span> maxWater = 0;

    <span class="keyword">while</span> (left < right) {
        <span class="keyword">const</span> w = right - left;
        <span class="keyword">const</span> h = Math.min(height[left], height[right]);
        
        maxWater = Math.max(maxWater, w * h);

        <span class="comment">// Greedily move the shorter wall</span>
        <span class="keyword">if</span> (height[left] < height[right]) {
            left++;
        } <span class="keyword">else</span> {
            right--;
        }
    }
    <span class="keyword">return</span> maxWater;
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            11. Valid Anagram
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Lego Bucket" Analogy</div>
            <div class="eli5-box">
                <p>Imagine two LEGO sets. The box says they build different things (one is a "Rat", one is "Art").</p>
                <p>To prove they are the "same" (anagrams), you dump both boxes onto the floor.</p>
                <p>You count the pieces: "1 Red Block, 2 Blue Blocks..."</p>
                <p>If both piles have the <strong>exact same count</strong> of every specific piece type, they are Anagrams. If one pile has an extra blue block, they are not.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Frequency Counter (Hash Map)</strong><br>
                Create a map of character counts for String A. Then iterate through String B and decrement the counts. If all counts return to zero, it's a match.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">isAnagram</span>(<span class="var">s</span>: string, <span class="var">t</span>: string): boolean {
    <span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="keyword">const</span> count = <span class="keyword">new</span> Map&lt;string, number&gt;();

    <span class="comment">// Count S</span>
    <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> s) {
        count.set(char, (count.get(char) || 0) + 1);
    }

    <span class="comment">// Subtract using T</span>
    <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> t) {
        <span class="keyword">if</span> (!count.has(char)) <span class="keyword">return</span> <span class="keyword">false</span>; // Unknown char
        count.set(char, count.get(char)! - 1);
        <span class="keyword">if</span> (count.get(char) === 0) count.delete(char);
    }

    <span class="keyword">return</span> count.size === 0;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            12. Group Anagrams
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Alphabet Soup" Sorting</div>
            <div class="eli5-box">
                <p>You are a librarian, but you have a weird filing system.</p>
                <p>When you get a book titled "EAT", you don't file it under E. You take the letters, boil them down, and sort them alphabetically: "AET".</p>
                <p>Later, a book titled "TEA" comes in. You boil it down... it also becomes "AET".</p>
                <p>You file them together in the same bin labeled "AET". Every word that shares the same ingredients goes in the same bin.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Canonical Representation (Sorting as Key)</strong><br>
                To group items, we need a common "Key".<br>
                Key logic: <code>word.split('').sort().join('')</code>.<br>
                Map logic: <code>Key -> [List of Words]</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">groupAnagrams</span>(<span class="var">strs</span>: string[]): string[][] {
    <span class="keyword">const</span> map = <span class="keyword">new</span> Map&lt;string, string[]&gt;();

    <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) {
        <span class="comment">// "eat" -> ['e','a','t'] -> ['a','e','t'] -> "aet"</span>
        <span class="keyword">const</span> key = s.split('').sort().join('');
        
        <span class="keyword">if</span> (!map.has(key)) {
            map.set(key, []);
        }
        map.get(key)!.push(s);
    }

    <span class="keyword">return</span> Array.from(map.values());
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            13. Valid Parentheses
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Dinner Plates" Stack</div>
            <div class="eli5-box">
                <p>Imagine a stack of dirty dinner plates. You can only wash the <strong>top</strong> plate.</p>
                <p>Every time you see an OPEN bracket like <code>(</code> or <code>{</code>, it's like putting a dirty plate on the stack.</p>
                <p>When you see a CLOSE bracket like <code>)</code>, you must wash the top plate. But the rule is: The closing bracket must MATCH the top plate.</p>
                <p>If you have a square plate <code>[</code> on top, but you try to wash it with a round lid <code>)</code>, it crashes. Error!</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Stack (Last In, First Out)</strong><br>
                Push opening brackets onto stack. When you see a closing bracket, Pop the top. If the popped item doesn't match the current closing bracket, invalid.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">isValid</span>(<span class="var">s</span>: string): boolean {
    <span class="keyword">const</span> stack: string[] = [];
    <span class="keyword">const</span> pairs: Record&lt;string, string&gt; = {
        ')': '(',
        ']': '[',
        '}': '{'
    };

    <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> s) {
        <span class="comment">// If it's a closing bracket (it exists as a key in pairs)</span>
        <span class="keyword">if</span> (char <span class="keyword">in</span> pairs) {
            <span class="comment">// Pop the top of stack and check if it matches</span>
            <span class="keyword">const</span> topElement = stack.pop();
            <span class="keyword">if</span> (topElement !== pairs[char]) {
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
        } <span class="keyword">else</span> {
            <span class="comment">// It's an opening bracket, push it</span>
            stack.push(char);
        }
    }

    <span class="comment">// Stack must be empty for it to be valid</span>
    <span class="keyword">return</span> stack.length === 0;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            14. Valid Palindrome
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Mirror Walk"</div>
            <div class="eli5-box">
                <p>The word is "RACE CAR".</p>
                <p>Imagine twins standing at opposite ends of the room (Start and End).</p>
                <p>They both take a step inward. Twin A sees 'R'. Twin B sees 'R'. Good.</p>
                <p>They step again. Twin A sees 'A'. Twin B sees 'A'. Good.</p>
                <p><strong>Note:</strong> If Twin A sees a piece of trash (a space or comma), he kicks it aside and steps again until he sees a letter. Same for Twin B.</p>
                <p>If they meet in the middle without finding a mismatch, it's a palindrome.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Two Pointers (Converging)</strong><br>
                One pointer at 0, one at Length-1. Move them toward center. Skip non-alphanumeric chars. Compare.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">isPalindrome</span>(<span class="var">s</span>: string): boolean {
    <span class="comment">// 1. Clean the string (Regex is easiest for interview)</span>
    <span class="keyword">const</span> clean = s.toLowerCase().replace(/[^a-z0-9]/g, '');
    
    <span class="keyword">let</span> left = 0;
    <span class="keyword">let</span> right = clean.length - 1;

    <span class="keyword">while</span> (left < right) {
        <span class="keyword">if</span> (clean[left] !== clean[right]) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        left++;
        right--;
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            15. Longest Substring Without Repeating...
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Caterpillar" Analogy</div>
            <div class="eli5-box">
                <p>Imagine a caterpillar crawling along a branch of letters: <code>A B C A B C B B</code>.</p>
                <p>The caterpillar wants to eat as many letters as possible, but it is allergic to eating the same letter twice inside its tummy.</p>
                <p>1. <strong>Head moves forward (Right):</strong> Eats A... eats B... eats C.</p>
                <p>2. <strong>Head sees A again:</strong> "Oh no! I already have an A in my tummy (at the tail)."</p>
                <p>3. <strong>Tail moves forward (Left):</strong> The caterpillar has to poop out letters from its tail until the old 'A' is gone. Only then can the Head eat the new 'A'.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Sliding Window + HashSet</strong><br>
                Window = <code>[Left, Right]</code>.<br>
                Expand <code>Right</code>. Check Set. If duplicate exists, contract <code>Left</code> and remove chars from Set until duplicate is resolved. Update Max Length at every step.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">lengthOfLongestSubstring</span>(<span class="var">s</span>: string): number {
    <span class="keyword">const</span> charSet = <span class="keyword">new</span> Set();
    <span class="keyword">let</span> left = 0;
    <span class="keyword">let</span> maxLength = 0;

    <span class="keyword">for</span> (<span class="keyword">let</span> right = 0; right < s.length; right++) {
        <span class="comment">// If current char is already in window, shrink window from left</span>
        <span class="keyword">while</span> (charSet.has(s[right])) {
            charSet.delete(s[left]);
            left++;
        }
        
        <span class="comment">// Add new char and measure size</span>
        charSet.add(s[right]);
        maxLength = Math.max(maxLength, right - left + 1);
    }
    <span class="keyword">return</span> maxLength;
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            16. Longest Repeating Char Replacement
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Magic Paint" Analogy</div>
            <div class="eli5-box">
                <p>You have a row of colored tiles: <code>A A B A B B A</code>.</p>
                <p>You have a bucket of Magic Paint that can change exactly <strong>K</strong> tiles to whatever color you want.</p>
                <p>You want the longest solid line of ONE color.</p>
                <p><strong>The Trick:</strong> You look at a window of tiles. You count the "Dominant Color" (the one that appears most). You assume you will use your paint to fix the <em>other</em> tiles (the minority).</p>
                <p>Formula: If <code>(Window Size) - (Count of Dominant Color)</code> is greater than <strong>K</strong>, you don't have enough paint! Shrink the window.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Sliding Window + Max Frequency Tracking</strong><br>
                Validity Condition: <code>(Right - Left + 1) - maxFrequency <= k</code>.<br>
                If invalid, increment Left pointer. Note: We don't actually need to decrement `maxFrequency` when shrinking, because the window only grows if we find a NEW max frequency that beats the historical best.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">characterReplacement</span>(<span class="var">s</span>: string, <span class="var">k</span>: number): number {
    <span class="keyword">const</span> count = <span class="keyword">new</span> Map&lt;string, number&gt;();
    <span class="keyword">let</span> res = 0;
    <span class="keyword">let</span> l = 0;
    <span class="keyword">let</span> maxFreq = 0;

    <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < s.length; r++) {
        <span class="comment">// Update count for current char</span>
        count.set(s[r], (count.get(s[r]) || 0) + 1);
        
        <span class="comment">// Update the "Anchor" frequency</span>
        maxFreq = Math.max(maxFreq, count.get(s[r])!);

        <span class="comment">// Calculate number of replacements needed</span>
        <span class="comment">// WindowLen - MaxFreq = Replacements Needed</span>
        <span class="keyword">if</span> ((r - l + 1) - maxFreq > k) {
            <span class="comment">// Not enough k to fix this window, shrink it</span>
            count.set(s[l], count.get(s[l])! - 1);
            l++;
        }

        res = Math.max(res, r - l + 1);
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            17. Minimum Window Substring
            <span class="difficulty" style="background: rgba(239, 68, 68, 0.2); color: #fecaca;">Hard</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Grocery List" Analogy</div>
            <div class="eli5-box">
                <p>You have a Grocery List: "A, B, C". (Target).</p>
                <p>You are walking down a very long aisle (String S). You want to find the <strong>shortest</strong> section of the aisle that contains everything on your list.</p>
                <ol>
                    <li><strong>Expand Right:</strong> Walk forward grabbing items until you have everything on the list. "Okay, I have A, B, and C!"</li>
                    <li><strong>Shrink Left:</strong> Now, try to make the section smaller by moving your starting point forward. "If I drop the first item, do I still have everything?"</li>
                    <li>Repeat until you find the smallest valid section.</li>
                </ol>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Dynamic Sliding Window</strong><br>
                1. Use a Map for the `Need`.<br>
                2. `Have` variable tracks how many unique required chars we currently satisfy.<br>
                3. Loop R: Add char. If matches need, `Have++`.<br>
                4. While `Have == Need`: Update result minLen. Remove char at L. If removing breaks a condition, `Have--`. Increment L.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">minWindow</span>(<span class="var">s</span>: string, <span class="var">t</span>: string): string {
    <span class="keyword">if</span> (t.length === 0) <span class="keyword">return</span> "";

    <span class="keyword">const</span> countT = <span class="keyword">new</span> Map&lt;string, number&gt;();
    <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> t) countT.set(c, (countT.get(c) || 0) + 1);

    <span class="keyword">let</span> have = 0, need = countT.size;
    <span class="keyword">let</span> res = [-1, -1];
    <span class="keyword">let</span> resLen = Infinity;
    <span class="keyword">let</span> l = 0;
    
    <span class="keyword">const</span> window = <span class="keyword">new</span> Map&lt;string, number&gt;();

    <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < s.length; r++) {
        <span class="keyword">const</span> c = s[r];
        window.set(c, (window.get(c) || 0) + 1);

        <span class="comment">// If this char satisfies the count requirement for T</span>
        <span class="keyword">if</span> (countT.has(c) && window.get(c) === countT.get(c)) {
            have++;
        }

        <span class="comment">// While window is valid, try to shrink it</span>
        <span class="keyword">while</span> (have === need) {
            <span class="comment">// Update result?</span>
            <span class="keyword">if</span> ((r - l + 1) < resLen) {
                res = [l, r];
                resLen = r - l + 1;
            }

            <span class="comment">// Pop from left</span>
            window.set(s[l], window.get(s[l])! - 1);
            <span class="keyword">if</span> (countT.has(s[l]) && window.get(s[l])! < countT.get(s[l])!) {
                have--;
            }
            l++;
        }
    }
    <span class="keyword">return</span> resLen === Infinity ? "" : s.slice(res[0], res[1] + 1);
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            18. Encode and Decode Strings
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Secret Divider"</div>
            <div class="eli5-box">
                <p>You want to send a list of words to a friend: <code>["hello", "world"]</code>.</p>
                <p>If you just smash them together: <code>"helloworld"</code>, your friend doesn't know where to split them.</p>
                <p>If you use a symbol like #: <code>"hello#world"</code>, what happens if the word itself contains a #? (e.g. <code>["C#", "Code"]</code> -> <code>"C##Code"</code>... confusing!).</p>
                <p><strong>The Solution:</strong> Tell them the LENGTH first. <code>"5#hello5#world"</code>. Your friend reads the number (5), skips the hash, and knows exactly how many letters to grab next.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Length-Prefix Framing</strong><br>
                Encoding Scheme: <code>${length}#${string}</code>.<br>
                Decoding Scheme: Read digits until `#`, parse int, read that many chars, repeat.
            </div>

            <pre>
<span class="keyword">class</span> Codec {
    <span class="comment">// Encodes a list of strings to a single string.</span>
    <span class="func">encode</span>(<span class="var">strs</span>: string[]): string {
        <span class="keyword">let</span> res = "";
        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) {
            res += s.length + "#" + s;
        }
        <span class="keyword">return</span> res;
    }

    <span class="comment">// Decodes a single string to a list of strings.</span>
    <span class="func">decode</span>(<span class="var">s</span>: string): string[] {
        <span class="keyword">const</span> res: string[] = [];
        <span class="keyword">let</span> i = 0;
        
        <span class="keyword">while</span> (i < s.length) {
            <span class="keyword">let</span> j = i;
            <span class="comment">// Find the delimiter #</span>
            <span class="keyword">while</span> (s[j] !== '#') {
                j++;
            }
            <span class="comment">// Parse length</span>
            <span class="keyword">const</span> length = parseInt(s.substring(i, j));
            
            <span class="comment">// Extract word</span>
            i = j + 1 + length; <span class="comment">// Jump past delimiter + length</span>
            res.push(s.substring(j + 1, i));
        }
        <span class="keyword">return</span> res;
    }
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            19. Top K Frequent Elements
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Vote Buckets"</div>
            <div class="eli5-box">
                <p>Imagine a school election. 1000 kids vote.</p>
                <p>You want the Top 2 winners. You <em>could</em> sort every single student by votes (slow).</p>
                <p><strong>Better Way:</strong> Make buckets labeled 1 to 1000 (representing vote counts).<br>
                If Bob gets 5 votes, put Bob in Bucket #5.<br>
                If Alice gets 100 votes, put Alice in Bucket #100.</p>
                <p>To find the winner, just walk backwards from the highest bucket (#1000). The first people you find are the winners.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Bucket Sort (O(n))</strong><br>
                1. Hash Map to count frequency of each number.<br>
                2. Create an array of arrays (buckets) where Index = Frequency.<br>
                3. Iterate buckets from end (Highest frequency) to start.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">topKFrequent</span>(<span class="var">nums</span>: number[], <span class="var">k</span>: number): number[] {
    <span class="keyword">const</span> count = <span class="keyword">new</span> Map&lt;number, number&gt;();
    <span class="keyword">const</span> freq = <span class="keyword">new</span> Array(nums.length + 1).fill(0).map(() => []);

    <span class="comment">// 1. Count votes</span>
    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> nums) {
        count.set(n, (count.get(n) || 0) + 1);
    }

    <span class="comment">// 2. Place in buckets (Index = Count)</span>
    <span class="keyword">for</span> (<span class="keyword">const</span> [num, c] <span class="keyword">of</span> count) {
        freq[c].push(num);
    }

    <span class="comment">// 3. Harvest from the end (Most frequent)</span>
    <span class="keyword">const</span> res: number[] = [];
    <span class="keyword">for</span> (<span class="keyword">let</span> i = freq.length - 1; i > 0; i--) {
        <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> freq[i]) {
            res.push(n);
            <span class="keyword">if</span> (res.length === k) <span class="keyword">return</span> res;
        }
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            20. Longest Consecutive Sequence
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Start of the Line"</div>
            <div class="eli5-box">
                <p>You have a bag of random numbers: <code>[100, 4, 200, 1, 3, 2]</code>.</p>
                <p>You want to find the longest chain <code>(1, 2, 3, 4)</code>.</p>
                <p>If you pick up the number <strong>2</strong>, should you start counting? <strong>NO.</strong> Why? Because <strong>1</strong> exists. 2 is not the start of a chain. It's the middle.</p>
                <p><strong>The Rule:</strong> Only start counting if you are the <strong>Beginning</strong> of a sequence. How do you know? Check if <code>(CurrentNumber - 1)</code> exists. If it doesn't, YOU are the start.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: HashSet + Intelligent Sequence Building</strong><br>
                1. Put all nums in a Set for O(1) lookup.<br>
                2. Iterate nums. Only enter the <code>while</code> loop if <code>!set.has(num-1)</code>.<br>
                3. This ensures each sequence is only processed ONCE. Total time O(N).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">longestConsecutive</span>(<span class="var">nums</span>: number[]): number {
    <span class="keyword">const</span> numSet = <span class="keyword">new</span> Set(nums);
    <span class="keyword">let</span> longest = 0;

    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> nums) {
        <span class="comment">// Check if 'n' is the start of a sequence</span>
        <span class="comment">// (i.e., n-1 does not exist)</span>
        <span class="keyword">if</span> (!numSet.has(n - 1)) {
            <span class="keyword">let</span> length = 0;
            <span class="keyword">while</span> (numSet.has(n + length)) {
                length++;
            }
            longest = Math.max(longest, length);
        }
    }
    <span class="keyword">return</span> longest;
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            21. Reverse Linked List
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Train Coupler"</div>
            <div class="eli5-box">
                <p>Imagine a train where car A pulls car B, and B pulls C.</p>
                <p>You want to reverse it so C pulls B, and B pulls A.</p>
                <p><strong>The Danger:</strong> If you unhook B from C to point it backwards at A, <strong>C floats away</strong> and is lost forever in space.</p>
                <p><strong>The Fix:</strong> You need 3 hands (pointers):<br>
                1. <strong>Prev:</strong> Holding the car behind you.<br>
                2. <strong>Curr:</strong> The car you are working on.<br>
                3. <strong>Next:</strong> A safety rope holding the car ahead of you <em>before</em> you unhook.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Iterative Pointer Reversal</strong><br>
                Save Next -> Break Link (point to Prev) -> Shift Prev/Curr forward.<br>
                Always return `prev` at the end (because `curr` will be null).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">reverseList</span>(<span class="var">head</span>: ListNode | null): ListNode | null {
    <span class="keyword">let</span> prev = <span class="keyword">null</span>;
    <span class="keyword">let</span> curr = head;

    <span class="keyword">while</span> (curr) {
        <span class="keyword">const</span> nextTemp = curr.next; <span class="comment">// 1. Save the future</span>
        curr.next = prev;           <span class="comment">// 2. Reverse the link</span>
        prev = curr;                <span class="comment">// 3. Move Prev forward</span>
        curr = nextTemp;            <span class="comment">// 4. Move Curr forward</span>
    }
    <span class="keyword">return</span> prev; <span class="comment">// Prev is the new Head</span>
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            22. Merge Two Sorted Lists
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Zipper"</div>
            <div class="eli5-box">
                <p>You have two lines of students sorted by height. You want to make one single sorted line.</p>
                <p>You stand at the front. You look at Student A (Line 1) and Student B (Line 2).</p>
                <p>"Who is shorter? You! Okay, come stand behind me."</p>
                <p>Then you repeat. If one line runs out of students, you just take the <strong>entire chunk</strong> of the remaining line and attach it to the end.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Dummy Node + Pointers</strong><br>
                Use a `dummy` node as a fake head so you don't have to write logic for "is this the first node?".<br>
                Use a `tail` pointer to build the new list. Move `list1` or `list2` pointers forward as you pick nodes.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">mergeTwoLists</span>(<span class="var">list1</span>: ListNode | null, <span class="var">list2</span>: ListNode | null): ListNode | null {
    <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode(0);
    <span class="keyword">let</span> tail = dummy;

    <span class="keyword">while</span> (list1 && list2) {
        <span class="keyword">if</span> (list1.val < list2.val) {
            tail.next = list1;
            list1 = list1.next;
        } <span class="keyword">else</span> {
            tail.next = list2;
            list2 = list2.next;
        }
        tail = tail.next;
    }

    <span class="comment">// Attach whatever is left (one list might still have nodes)</span>
    <span class="keyword">if</span> (list1) tail.next = list1;
    <span class="keyword">else</span> <span class="keyword">if</span> (list2) tail.next = list2;

    <span class="keyword">return</span> dummy.next;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            23. Reorder List
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Origami Strip"</div>
            <div class="eli5-box">
                <p>You have a strip of paper: <code>1 -> 2 -> 3 -> 4 -> 5</code>.</p>
                <p>You want to fold it to look like: <code>1 -> 5 -> 2 -> 4 -> 3</code> (Start, End, Start+1, End-1...).</p>
                <p>This is actually 3 easy problems wearing a trench coat:</p>
                <ol>
                    <li><strong>Find the Middle:</strong> Cut the strip in half. (Left: 1-2-3, Right: 4-5).</li>
                    <li><strong>Reverse the Right Half:</strong> Flip the second strip. (Right becomes: 5-4).</li>
                    <li><strong>Merge Them:</strong> Zipper them together (1 -> 5 -> 2 -> 4...).</li>
                </ol>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Fast/Slow Pointers + Reverse + Merge</strong><br>
                1. <code>Slow/Fast</code> to find middle.<br>
                2. <code>Reverse</code> linked list (like Prob 21) on the second half.<br>
                3. Alternating merge logic.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">reorderList</span>(<span class="var">head</span>: ListNode | null): void {
    <span class="keyword">if</span> (!head) <span class="keyword">return</span>;

    <span class="comment">// 1. Find Middle</span>
    <span class="keyword">let</span> slow = head, fast = head.next;
    <span class="keyword">while</span> (fast && fast.next) {
        slow = slow.next!;
        fast = fast.next.next;
    }

    <span class="comment">// 2. Reverse Second Half</span>
    <span class="keyword">let</span> second = slow.next;
    slow.next = <span class="keyword">null</span>; <span class="comment">// Cut the connection</span>
    <span class="keyword">let</span> prev = <span class="keyword">null</span>;
    <span class="keyword">while</span> (second) {
        <span class="keyword">let</span> temp = second.next;
        second.next = prev;
        prev = second;
        second = temp;
    }
    <span class="comment">// prev is now the head of the reversed second half</span>

    <span class="comment">// 3. Merge Two Halves</span>
    <span class="keyword">let</span> first = head;
    second = prev;
    <span class="keyword">while</span> (second) {
        <span class="keyword">let</span> tmp1 = first.next;
        <span class="keyword">let</span> tmp2 = second.next;
        
        first.next = second;
        second.next = tmp1;
        
        first = tmp1!;
        second = tmp2;
    }
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            24. Remove Nth Node From End
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Stick" Technique</div>
            <div class="eli5-box">
                <p>You need to remove the 3rd person from the <strong>end</strong> of the line.</p>
                <p>Problem: You don't know how long the line is. You could count the whole line, then walk back, but that's two trips.</p>
                <p><strong>Smart Way:</strong> Hold a stick that is exactly 3 people long.</p>
                <p>Put the front of the stick at the start. Move the stick forward until the front touches the end of the line. The back of the stick is now exactly at the person you need to remove!</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Two Pointers (Gap Method)</strong><br>
                1. Move <code>Right</code> pointer N steps ahead.<br>
                2. Move <code>Left</code> and <code>Right</code> together until Right hits the end.<br>
                3. <code>Left</code> is now at the node <em>before</em> the target. Do <code>Left.next = Left.next.next</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">removeNthFromEnd</span>(<span class="var">head</span>: ListNode | null, <span class="var">n</span>: number): ListNode | null {
    <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode(0, head);
    <span class="keyword">let</span> left = dummy;
    <span class="keyword">let</span> right = head;

    <span class="comment">// 1. Advance Right by n steps</span>
    <span class="keyword">while</span> (n > 0 && right) {
        right = right.next;
        n--;
    }

    <span class="comment">// 2. Move both until Right hits end</span>
    <span class="keyword">while</span> (right) {
        left = left.next!;
        right = right.next;
    }

    <span class="comment">// 3. Delete node</span>
    left.next = left.next!.next;

    <span class="keyword">return</span> dummy.next;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            25. Linked List Cycle
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Race Track"</div>
            <div class="eli5-box">
                <p>Imagine a race track. You have a Fast Runner (2 steps) and a Slow Runner (1 step).</p>
                <p><strong>Scenario A (Straight Line):</strong> The Fast runner eventually crosses the finish line (reaches null). Game over, no cycle.</p>
                <p><strong>Scenario B (Circle/Loop):</strong> The Fast runner will never finish. Instead, they will loop around and eventually <strong>lap</strong> the Slow runner from behind. If they ever crash into each other, you know it's a loop.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Floyd's Tortoise and Hare</strong><br>
                Initialize <code>slow</code> and <code>fast</code> at Head.<br>
                Loop while <code>fast</code> and <code>fast.next</code> exist.<br>
                If <code>slow === fast</code>, return true.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">hasCycle</span>(<span class="var">head</span>: ListNode | null): boolean {
    <span class="keyword">let</span> slow = head;
    <span class="keyword">let</span> fast = head;

    <span class="keyword">while</span> (fast && fast.next) {
        slow = slow!.next;
        fast = fast.next.next;
        
        <span class="keyword">if</span> (slow === fast) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}</pre>
        </div>
    </div>
    <div class="pattern-group" style="margin-top: 60px;">
        <h1>Set 2: Structure (Trees & Heaps)</h1>
        <p>Focus: Non-linear data, recursion, and hierarchies.</p>
    </div>

    <div class="problem-card">
        <div class="header">
            26. Merge K Sorted Lists
            <span class="difficulty" style="background: rgba(239, 68, 68, 0.2); color: #fecaca;">Hard</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Champion of Champions"</div>
            <div class="eli5-box">
                <p>You have 10 different lines of students, all sorted by height. You want 1 giant sorted line.</p>
                <p><strong>The Slow Way:</strong> Look at the front person of ALL 10 lines every single time. (Too much turning your head).</p>
                <p><strong>The Smart Way (Min-Heap):</strong> Invite the front person of each line into a small room (The Heap). The Heap instantly tells you who is shortest. You pick them. Then, you only invite <em>the next person from that specific winner's line</em> into the room.</p>
                <p><strong>The Alternative (Divide & Conquer):</strong> Merge Line 1 & 2. Merge Line 3 & 4... Then merge the winners. Like a sports tournament bracket!</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Divide & Conquer (Merge Sort Logic)</strong><br>
                We already solved "Merge 2 Lists" (Prob 22).<br>
                Instead of merging K lists at once, pair them up. Merge(L1, L2), Merge(L3, L4)... <br>
                We reduce K lists to K/2, then K/4, until only 1 remains. Time: O(N log K).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">mergeKLists</span>(<span class="var">lists</span>: Array&lt;ListNode | null&gt;): ListNode | null {
    <span class="keyword">if</span> (lists.length === 0) <span class="keyword">return</span> <span class="keyword">null</span>;

    <span class="keyword">while</span> (lists.length > 1) {
        <span class="keyword">const</span> mergedLists: Array&lt;ListNode | null&gt; = [];
        
        <span class="comment">// Process pairs of lists</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < lists.length; i += 2) {
            <span class="keyword">const</span> l1 = lists[i];
            <span class="keyword">const</span> l2 = (i + 1 < lists.length) ? lists[i + 1] : <span class="keyword">null</span>;
            <span class="comment">// Reuse our mergeTwoLists function from Q22</span>
            mergedLists.push(mergeTwoLists(l1, l2));
        }
        lists = mergedLists;
    }
    <span class="keyword">return</span> lists[0];
}

<span class="comment">// Helper from Q22</span>
<span class="keyword">function</span> <span class="func">mergeTwoLists</span>(<span class="var">l1</span>: ListNode | null, <span class="var">l2</span>: ListNode | null): ListNode | null {
    <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode(0);
    <span class="keyword">let</span> tail = dummy;
    <span class="keyword">while</span> (l1 && l2) {
        <span class="keyword">if</span> (l1.val < l2.val) { tail.next = l1; l1 = l1.next; }
        <span class="keyword">else</span> { tail.next = l2; l2 = l2.next; }
        tail = tail.next;
    }
    <span class="keyword">if</span> (l1) tail.next = l1;
    <span class="keyword">if</span> (l2) tail.next = l2;
    <span class="keyword">return</span> dummy.next;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            27. Invert Binary Tree
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Mirror Dimension"</div>
            <div class="eli5-box">
                <p>This is the famous "Homebrew" interview question!</p>
                <p>Imagine a family tree. You want to flip it so every Left child becomes a Right child, and vice versa.</p>
                <p>You (The Boss) stand at the top. You swap your two children. Then you tell your Left Child: "Hey, do exactly what I just did." And you tell your Right Child: "You too, swap your kids."</p>
                <p>They repeat this all the way down until there are no kids left.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Depth First Search (DFS) - Pre-order</strong><br>
                1. Swap <code>node.left</code> and <code>node.right</code>.<br>
                2. Recursively call <code>invertTree(node.left)</code>.<br>
                3. Recursively call <code>invertTree(node.right)</code>.<br>
                Base case: If node is null, return null.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">invertTree</span>(<span class="var">root</span>: TreeNode | null): TreeNode | null {
    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">null</span>;

    <span class="comment">// The Swap</span>
    <span class="keyword">const</span> temp = root.left;
    root.left = root.right;
    root.right = temp;

    <span class="comment">// The Delegation</span>
    invertTree(root.left);
    invertTree(root.right);

    <span class="keyword">return</span> root;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            28. Maximum Depth of Binary Tree
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Relay Race"</div>
            <div class="eli5-box">
                <p>You want to know how deep the rabbit hole goes.</p>
                <p>You stand at the top. You ask your Left Child: "How deep is your path?"<br>
                You ask your Right Child: "How deep is your path?"</p>
                <p>They don't know yet. They ask <em>their</em> children. <br>
                Eventually, someone at the bottom (a leaf) says "I have no kids, so my depth is 1."</p>
                <p>The answer bubbles up: <code>My Depth = 1 + Max(LeftDepth, RightDepth)</code>.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DFS (Post-order Calculation)</strong><br>
                Recursive Rule: Return <code>1 + Math.max(dfs(left), dfs(right))</code>.<br>
                Base Case: If root is null, return 0.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">maxDepth</span>(<span class="var">root</span>: TreeNode | null): number {
    <span class="keyword">if</span> (!root) <span class="keyword">return</span> 0;

    <span class="keyword">const</span> leftDepth = maxDepth(root.left);
    <span class="keyword">const</span> rightDepth = maxDepth(root.right);

    <span class="keyword">return</span> 1 + Math.max(leftDepth, rightDepth);
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            29. Same Tree
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Spot the Difference"</div>
            <div class="eli5-box">
                <p>You have two trees, P and Q. Are they clones?</p>
                <p>You compare the top nodes. <br>
                1. Are they both empty? (Yes -> Good)<br>
                2. is one empty and the other not? (Yes -> BAD! Not clones).<br>
                3. Are the values different? (Yes -> BAD!).</p>
                <p>If the tops match, you delegate: "Okay Left side, check if YOU match. Right side, check if YOU match."</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Simultaneous DFS</strong><br>
                We traverse two trees at the same time.<br>
                Rule: <code>isSame(p.left, q.left) && isSame(p.right, q.right)</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">isSameTree</span>(<span class="var">p</span>: TreeNode | null, <span class="var">q</span>: TreeNode | null): boolean {
    <span class="comment">// 1. Both empty? True.</span>
    <span class="keyword">if</span> (!p && !q) <span class="keyword">return</span> <span class="keyword">true</span>;
    
    <span class="comment">// 2. One empty or values mismatch? False.</span>
    <span class="keyword">if</span> (!p || !q || p.val !== q.val) <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="comment">// 3. Check children recursively</span>
    <span class="keyword">return</span> isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            30. Subtree of Another Tree
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: "Finding Waldo"</div>
            <div class="eli5-box">
                <p>You have a Big Tree (Root) and a Small Tree (SubRoot).</p>
                <p>You want to see if the Small Tree exists exactly inside the Big Tree.</p>
                <p>You act like a scanner. You visit every node in the Big Tree.</p>
                <p>At every node, you stop and ask: "Does the tree starting RIGHT HERE look exactly like the Small Tree?" (We use the solution from Q29 'Same Tree' to check this!).</p>
                <p>If yes, we found it. If no, keep scanning.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DFS + Helper Function</strong><br>
                For every node in Main Tree, call <code>isSameTree(node, subRoot)</code>.<br>
                If it returns true, we win. If not, try <code>node.left</code> or <code>node.right</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">isSubtree</span>(<span class="var">root</span>: TreeNode | null, <span class="var">subRoot</span>: TreeNode | null): boolean {
    <span class="keyword">if</span> (!subRoot) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Empty set is always a subtree</span>
    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// Big tree empty, but subRoot isn't</span>

    <span class="comment">// Check if they match right here</span>
    <span class="keyword">if</span> (isSameTree(root, subRoot)) <span class="keyword">return</span> <span class="keyword">true</span>;

    <span class="comment">// If not, try the children</span>
    <span class="keyword">return</span> isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
}

<span class="comment">// Helper (Same as Q29)</span>
<span class="keyword">function</span> <span class="func">isSameTree</span>(<span class="var">p</span>: TreeNode | null, <span class="var">q</span>: TreeNode | null): boolean {
    <span class="keyword">if</span> (!p && !q) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (!p || !q || p.val !== q.val) <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="keyword">return</span> isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            31. Lowest Common Ancestor (BST)
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Split in the Road"</div>
            <div class="eli5-box">
                <p>You are walking down a road (The Tree) looking for two houses: P and Q.</p>
                <p>Because this is a BST, the signs are clear: "Smaller numbers Left, Bigger numbers Right."</p>
                <p>1. If both P and Q are smaller than where you are standing -> <strong>Go Left.</strong><br>
                2. If both P and Q are bigger -> <strong>Go Right.</strong><br>
                3. If P is on your left and Q is on your right (or you are standing on one of them) -> <strong>STOP.</strong> You are the split point. You are the Lowest Common Ancestor.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: BST Property Navigation</strong><br>
                We don't need to search the whole tree. We just follow the values.<br>
                Time: O(log N) - Height of tree. Space: O(1).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">lowestCommonAncestor</span>(<span class="var">root</span>: TreeNode | null, <span class="var">p</span>: TreeNode, <span class="var">q</span>: TreeNode): TreeNode | null {
    <span class="keyword">let</span> curr = root;

    <span class="keyword">while</span> (curr) {
        <span class="keyword">if</span> (p.val < curr.val && q.val < curr.val) {
            <span class="comment">// Both are smaller -> Go Left</span>
            curr = curr.left;
        } <span class="keyword">else</span> <span class="keyword">if</span> (p.val > curr.val && q.val > curr.val) {
            <span class="comment">// Both are larger -> Go Right</span>
            curr = curr.right;
        } <span class="keyword">else</span> {
            <span class="comment">// We found the split point (or one is the parent of the other)</span>
            <span class="keyword">return</span> curr;
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            32. Binary Tree Level Order Traversal
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Elevator"</div>
            <div class="eli5-box">
                <p>Usually, we explore trees by diving deep (Recursion/DFS). But here, we want to go floor-by-floor.</p>
                <p><strong>The Strategy:</strong> Use a waiting line (Queue).</p>
                <p>1. Put the Boss (Root) in the line.<br>
                2. Take the Boss out, write down his name. Put his children (Left & Right) in the back of the line.<br>
                3. Take the next person out, write name, put <em>their</em> children in the back.<br>
                4. Repeat until the line is empty.</p>
            </div>
            

[Image of breadth first search vs depth first search tree]


            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: BFS (Breadth First Search) with Queue</strong><br>
                Process level by level. <br>
                Inside the <code>while(queue)</code>, use a <code>for</code> loop of size <code>queue.length</code> to process exactly one level at a time.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">levelOrder</span>(<span class="var">root</span>: TreeNode | null): number[][] {
    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];

    <span class="keyword">const</span> res: number[][] = [];
    <span class="keyword">const</span> queue: TreeNode[] = [root];

    <span class="keyword">while</span> (queue.length > 0) {
        <span class="keyword">const</span> levelSize = queue.length;
        <span class="keyword">const</span> currentLevel: number[] = [];

        <span class="comment">// Process everyone currently in the queue (This Level)</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < levelSize; i++) {
            <span class="keyword">const</span> node = queue.shift()!;
            currentLevel.push(node.val);

            <span class="keyword">if</span> (node.left) queue.push(node.left);
            <span class="keyword">if</span> (node.right) queue.push(node.right);
        }
        res.push(currentLevel);
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            33. Validate Binary Search Tree
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Security Clearance"</div>
            <div class="eli5-box">
                <p>Just checking "Is Left < Me < Right" is <strong>NOT ENOUGH</strong>.</p>
                <p><em>Example Failure:</em> Root 10, Right Child 20. <br>Right Child's Left Child is 5. <br>5 is less than 20 (Good?), but 5 is to the right of 10 (BAD!).</p>
                <p><strong>The Fix:</strong> Every node has a strict range <code>(min, max)</code> allowed.</p>
                <ul>
                    <li>Root: (-Infinity, +Infinity)</li>
                    <li>Go Left: Max becomes Parent's value. Range: (-Inf, Parent)</li>
                    <li>Go Right: Min becomes Parent's value. Range: (Parent, +Inf)</li>
                </ul>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DFS with Range Tracking</strong><br>
                Pass <code>min</code> and <code>max</code> down the recursion. If <code>node.val</code> violates these bounds, return false.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">isValidBST</span>(<span class="var">root</span>: TreeNode | null): boolean {
    
    <span class="keyword">function</span> validate(node: TreeNode | null, min: number, max: number): boolean {
        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="keyword">true</span>;

        <span class="comment">// Violation Check</span>
        <span class="keyword">if</span> (node.val <= min || node.val >= max) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        <span class="comment">// Go Left: Max allowed is current node</span>
        <span class="comment">// Go Right: Min allowed is current node</span>
        <span class="keyword">return</span> validate(node.left, min, node.val) &&
               validate(node.right, node.val, max);
    }

    <span class="keyword">return</span> validate(root, -Infinity, Infinity);
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            34. Kth Smallest Element in a BST
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Roll Call"</div>
            <div class="eli5-box">
                <p>You want the K-th smallest person.</p>
                <p>In a BST, if you traverse strictly <strong>Left -> Parent -> Right</strong>, you are visiting nodes in perfect sorted order (1, 2, 3, 4...).</p>
                <p>So, just do that walk! Keep a counter. "One... Two... Three..." <br>When the counter hits K, stop walking. That's your answer.</p>
            </div>
            

[Image of binary search tree inorder traversal]


            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Inorder Traversal (Iterative is easier here)</strong><br>
                Use a Stack to simulate recursion. Go Left as much as possible. Pop (Process Node). Then Go Right.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">kthSmallest</span>(<span class="var">root</span>: TreeNode | null, <span class="var">k</span>: number): number {
    <span class="keyword">const</span> stack: TreeNode[] = [];
    <span class="keyword">let</span> curr = root;
    <span class="keyword">let</span> count = 0;

    <span class="keyword">while</span> (curr || stack.length > 0) {
        <span class="comment">// 1. Go as Left as possible</span>
        <span class="keyword">while</span> (curr) {
            stack.push(curr);
            curr = curr.left;
        }

        <span class="comment">// 2. Process Node (Smallest available)</span>
        curr = stack.pop()!;
        count++;
        
        <span class="keyword">if</span> (count === k) <span class="keyword">return</span> curr.val;

        <span class="comment">// 3. Go Right</span>
        curr = curr.right;
    }
    <span class="keyword">return</span> -1;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            35. Construct Binary Tree
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Instruction Manual"</div>
            <div class="eli5-box">
                <p>You have a bag of parts (nodes) and two instruction sheets.</p>
                <p><strong>Sheet 1 (Preorder):</strong> Lists the Bosses first. The first item is ALWAYS the Root.</p>
                <p><strong>Sheet 2 (Inorder):</strong> Tells you who sits to the Left of the Boss and who sits to the Right.</p>
                <p><strong>Strategy:</strong><br>
                1. Pick first item from Preorder. That's the Root.<br>
                2. Find that Root in the Inorder list.<br>
                3. Everyone to the left in Inorder belongs to the Left Subtree. Everyone to the right belongs to the Right Subtree.<br>
                4. Repeat recursively.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Recursion + HashMap (for O(1) Index Lookup)</strong><br>
                The <code>preorder</code> index tells us the root. The <code>inorder</code> range tells us the subtree size.<br>
                Map Inorder values to indices for speed.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">buildTree</span>(<span class="var">preorder</span>: number[], <span class="var">inorder</span>: number[]): TreeNode | null {
    <span class="keyword">const</span> inorderMap = <span class="keyword">new</span> Map&lt;number, number&gt;();
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < inorder.length; i++) {
        inorderMap.set(inorder[i], i);
    }

    <span class="keyword">let</span> preIdx = 0;

    <span class="keyword">function</span> build(left: number, right: number): TreeNode | null {
        <span class="comment">// Base case: No elements left in this range</span>
        <span class="keyword">if</span> (left > right) <span class="keyword">return</span> <span class="keyword">null</span>;

        <span class="comment">// 1. Pick Root from Preorder</span>
        <span class="keyword">const</span> rootVal = preorder[preIdx];
        preIdx++;
        <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(rootVal);

        <span class="comment">// 2. Split Inorder using the root's index</span>
        <span class="keyword">const</span> mid = inorderMap.get(rootVal)!;

        <span class="comment">// 3. Build Left (Preorder naturally goes Left next)</span>
        root.left = build(left, mid - 1);
        
        <span class="comment">// 4. Build Right</span>
        root.right = build(mid + 1, right);

        <span class="keyword">return</span> root;
    }

    <span class="keyword">return</span> build(0, inorder.length - 1);
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            36. Binary Tree Maximum Path Sum
            <span class="difficulty" style="background: rgba(239, 68, 68, 0.2); color: #fecaca;">Hard</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Greedy Hiker"</div>
            <div class="eli5-box">
                <p>You are hiking on a mountain (Tree). Each checkpoint has a value (Gold coins or Debt).</p>
                <p>You want the path with the most coins. The rule is: A path is a single line. You can't branch off and come back.</p>
                <p><strong>The Dilemma:</strong> At any checkpoint (Node), you have two choices:</p>
                <ol>
                    <li><strong>The Split:</strong> "I will connect my Left path and my Right path here. This becomes a 'U' shape. I am the top. The path ends here (Max Path)."</li>
                    <li><strong>The Relay:</strong> "I will pick my BEST side (Left or Right) and add myself to it, then pass that sum up to my parent."</li>
                </ol>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DFS with Global State Update</strong><br>
                1. Calculate `leftMax` and `rightMax` (recursively). treat negative values as 0 (don't take that path).<br>
                2. Calculate `splitMax` = `left + right + node.val`. Update Global Maximum with this.<br>
                3. Return `node.val + max(left, right)` to the parent (continuation).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">maxPathSum</span>(<span class="var">root</span>: TreeNode | null): number {
    <span class="keyword">let</span> globalMax = -Infinity;

    <span class="keyword">function</span> dfs(node: TreeNode | null): number {
        <span class="keyword">if</span> (!node) <span class="keyword">return</span> 0;

        <span class="comment">// 1. Get max from children (ignore negative paths)</span>
        <span class="keyword">const</span> left = Math.max(dfs(node.left), 0);
        <span class="keyword">const</span> right = Math.max(dfs(node.right), 0);

        <span class="comment">// 2. Calculate the "Split" path (The U-Turn)</span>
        <span class="comment">// Update global record, but DO NOT return this</span>
        globalMax = Math.max(globalMax, node.val + left + right);

        <span class="comment">// 3. Return the "Relay" path (Straight line)</span>
        <span class="keyword">return</span> node.val + Math.max(left, right);
    }

    dfs(root);
    <span class="keyword">return</span> globalMax;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            37. Serialize & Deserialize Tree
            <span class="difficulty" style="background: rgba(239, 68, 68, 0.2); color: #fecaca;">Hard</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Teleporter"</div>
            <div class="eli5-box">
                <p>You have a LEGO castle (Tree). You want to email it to a friend.</p>
                <p>You can't email physical blocks. You must write instructions.</p>
                <p><strong>Encoding:</strong> You walk through the castle. "Root is 1. Left is 2. Left is Null. Right is Null..."<br>
                Crucial Step: You MUST write down "Null" (or "X") whenever a spot is empty, otherwise your friend won't know when a branch ends.</p>
                <p><strong>Decoding:</strong> Your friend reads the string. "1... okay Root. 2... okay Left Child. X... okay, stop going Left, go back up."</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Preorder Traversal with Delimiters</strong><br>
                Serialize: DFS Preorder. Push "null" string for nulls.<br>
                Deserialize: Split string by delimiter. Use a global index/pointer to reconstruct recursively.
            </div>

            <pre>
<span class="keyword">class</span> Codec {
    <span class="comment">// Encodes a tree to a single string.</span>
    <span class="func">serialize</span>(<span class="var">root</span>: TreeNode | null): string {
        <span class="keyword">const</span> res: string[] = [];
        
        <span class="keyword">function</span> dfs(node: TreeNode | null) {
            <span class="keyword">if</span> (!node) {
                res.push("N"); <span class="comment">// N for Null</span>
                <span class="keyword">return</span>;
            }
            res.push(node.val.toString());
            dfs(node.left);
            dfs(node.right);
        }
        dfs(root);
        <span class="keyword">return</span> res.join(",");
    }

    <span class="comment">// Decodes your encoded data to tree.</span>
    <span class="func">deserialize</span>(<span class="var">data</span>: string): TreeNode | null {
        <span class="keyword">const</span> vals = data.split(",");
        <span class="keyword">let</span> i = 0;

        <span class="keyword">function</span> dfs(): TreeNode | null {
            <span class="keyword">if</span> (vals[i] === "N") {
                i++;
                <span class="keyword">return</span> <span class="keyword">null</span>;
            }
            <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(parseInt(vals[i]));
            i++;
            node.left = dfs();
            node.right = dfs();
            <span class="keyword">return</span> node;
        }
        <span class="keyword">return</span> dfs();
    }
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            38. Implement Trie (Prefix Tree)
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Autocomplete" Brain</div>
            <div class="eli5-box">
                <p>How does your phone know "App" could become "Apple" or "Apply"?</p>
                <p>It doesn't store words in a list. It stores them as a path of letters.</p>
                <p><strong>Root -> A -> P -> P</strong></p>
                <p>At the second 'P', the road splits. One road goes to 'L' (Apple). One road goes to 'L' -> 'Y' (Apply).</p>
                <p>To check if a word exists, you just walk the road. If the road ends abruptly, the word isn't there.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: N-ary Tree (Map/Object children)</strong><br>
                Each Node has: <br>
                1. `children`: Map&lt;char, TrieNode&gt;<br>
                2. `isEnd`: boolean (Does a word actually finish here? "App" is a prefix of "Apple", but is "App" a word? Only if isEnd is true at the second P).
            </div>

            <pre>
<span class="keyword">class</span> TrieNode {
    children: Map&lt;string, TrieNode&gt; = <span class="keyword">new</span> Map();
    isEnd: boolean = <span class="keyword">false</span>;
}

<span class="keyword">class</span> Trie {
    root: TrieNode;

    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();
    }

    <span class="func">insert</span>(<span class="var">word</span>: string): void {
        <span class="keyword">let</span> curr = <span class="keyword">this</span>.root;
        <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> word) {
            <span class="keyword">if</span> (!curr.children.has(char)) {
                curr.children.set(char, <span class="keyword">new</span> TrieNode());
            }
            curr = curr.children.get(char)!;
        }
        curr.isEnd = <span class="keyword">true</span>;
    }

    <span class="func">search</span>(<span class="var">word</span>: string): boolean {
        <span class="keyword">let</span> curr = <span class="keyword">this</span>.root;
        <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> word) {
            <span class="keyword">if</span> (!curr.children.has(char)) <span class="keyword">return</span> <span class="keyword">false</span>;
            curr = curr.children.get(char)!;
        }
        <span class="keyword">return</span> curr.isEnd;
    }

    <span class="func">startsWith</span>(<span class="var">prefix</span>: string): boolean {
        <span class="keyword">let</span> curr = <span class="keyword">this</span>.root;
        <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> prefix) {
            <span class="keyword">if</span> (!curr.children.has(char)) <span class="keyword">return</span> <span class="keyword">false</span>;
            curr = curr.children.get(char)!;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            39. Design Add & Search (Wildcard)
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Crossword" Helper</div>
            <div class="eli5-box">
                <p>This is a Trie, but with a twist: The "Magic Dot" (<code>.</code>).</p>
                <p>Searching "bad" is easy. Walk B -> A -> D.</p>
                <p>Searching "b.d" is hard. You walk to B. Then you see a DOT.</p>
                <p>The Dot means: <strong>"Try Every Possible Door."</strong></p>
                <p>You have to clone yourself. One clone goes through 'a', one through 'e', one through 'i'... if <em>any</em> clone finds the path to 'd', you win.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Trie + DFS Backtracking</strong><br>
                Standard Trie traversal, but when `char === '.'`, we must iterate over `Object.values(node.children)` and call DFS on all of them.
            </div>

            <pre>
<span class="keyword">class</span> WordDictionary {
    root: TrieNode; <span class="comment">// Reuse TrieNode from Q38</span>

    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();
    }

    <span class="func">addWord</span>(<span class="var">word</span>: string): void {
        <span class="keyword">let</span> curr = <span class="keyword">this</span>.root;
        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> word) {
            <span class="keyword">if</span> (!curr.children.has(c)) curr.children.set(c, <span class="keyword">new</span> TrieNode());
            curr = curr.children.get(c)!;
        }
        curr.isEnd = <span class="keyword">true</span>;
    }

    <span class="func">search</span>(<span class="var">word</span>: string): boolean {
        <span class="keyword">function</span> dfs(node: TrieNode, i: number): boolean {
            <span class="comment">// If we reached end of word, check if node marks an end</span>
            <span class="keyword">if</span> (i === word.length) <span class="keyword">return</span> node.isEnd;

            <span class="keyword">const</span> char = word[i];

            <span class="keyword">if</span> (char === '.') {
                <span class="comment">// Wildcard: Try ALL children</span>
                <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> node.children.values()) {
                    <span class="keyword">if</span> (dfs(child, i + 1)) <span class="keyword">return</span> <span class="keyword">true</span>;
                }
                <span class="keyword">return</span> <span class="keyword">false</span>;
            } <span class="keyword">else</span> {
                <span class="comment">// Normal char match</span>
                <span class="keyword">if</span> (!node.children.has(char)) <span class="keyword">return</span> <span class="keyword">false</span>;
                <span class="keyword">return</span> dfs(node.children.get(char)!, i + 1);
            }
        }
        <span class="keyword">return</span> dfs(<span class="keyword">this</span>.root, 0);
    }
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            40. Word Search II (Boggle)
            <span class="difficulty" style="background: rgba(239, 68, 68, 0.2); color: #fecaca;">Hard</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Reverse Lookup"</div>
            <div class="eli5-box">
                <p>You have a grid of letters and a list of 1,000 words. Find all words in the grid.</p>
                <p><strong>The Slow Way:</strong> Pick word #1 ("APPLE"). Search the whole grid. Pick word #2 ("BANANA"). Search the whole grid...</p>
                <p><strong>The Smart Way:</strong> Put all 1,000 words into a <strong>Trie</strong>.</p>
                <p>Now, walk the grid <strong>ONCE</strong>. As you step from letter to letter, check the Trie: "Does this path exist in my dictionary?"</p>
                <p>If you hit a node that says <code>isEnd = true</code>, you found a word! If you hit a dead end in the Trie, stop walking that path immediately.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Grid DFS + Trie Pruning</strong><br>
                1. Build Trie from words.<br>
                2. Iterate every cell (r, c) in grid. Start DFS.<br>
                3. DFS matches grid char to Trie child. <br>
                4. Optimization: If we find a word, remove it from Trie (to avoid duplicates). If a Trie Node has no children, prune it.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">findWords</span>(<span class="var">board</span>: string[][], <span class="var">words</span>: string[]): string[] {
    <span class="comment">// 1. Build Trie</span>
    <span class="keyword">const</span> root = <span class="keyword">new</span> TrieNode();
    <span class="keyword">for</span> (<span class="keyword">const</span> w <span class="keyword">of</span> words) {
        <span class="keyword">let</span> curr = root;
        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> w) {
            <span class="keyword">if</span> (!curr.children.has(c)) curr.children.set(c, <span class="keyword">new</span> TrieNode());
            curr = curr.children.get(c)!;
        }
        curr.word = w; <span class="comment">// Store full word at end node for easy access</span>
    }

    <span class="keyword">const</span> res: string[] = [];
    <span class="keyword">const</span> ROWS = board.length, COLS = board[0].length;
    <span class="keyword">const</span> visited = <span class="keyword">new</span> Set&lt;string&gt;();

    <span class="keyword">function</span> dfs(r: number, c: number, node: TrieNode) {
        <span class="keyword">if</span> (r < 0 || c < 0 || r >= ROWS || c >= COLS || 
            visited.has(`${r},${c}`) || !node.children.has(board[r][c])) {
            <span class="keyword">return</span>;
        }

        visited.add(`${r},${c}`);
        <span class="keyword">const</span> currNode = node.children.get(board[r][c])!;
        
        <span class="keyword">if</span> (currNode.word) {
            res.push(currNode.word);
            currNode.word = <span class="keyword">null</span>; <span class="comment">// Avoid duplicates</span>
        }

        dfs(r + 1, c, currNode);
        dfs(r - 1, c, currNode);
        dfs(r, c + 1, currNode);
        dfs(r, c - 1, currNode);

        visited.delete(`${r},${c}`);
    }

    <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < ROWS; r++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> c = 0; c < COLS; c++) {
            dfs(r, c, root);
        }
    }
    <span class="keyword">return</span> res;
}

<span class="comment">// Slight modification to TrieNode for this problem</span>
<span class="keyword">class</span> TrieNode {
    children = <span class="keyword">new</span> Map&lt;string, TrieNode&gt;();
    word: string | null = <span class="keyword">null</span>;
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            41. Find Median from Data Stream
            <span class="difficulty" style="background: rgba(239, 68, 68, 0.2); color: #fecaca;">Hard</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Split Classroom"</div>
            <div class="eli5-box">
                <p>You have a stream of students entering a room. You want to know the median height (the middle student).</p>
                <p><strong>The Strategy:</strong> Split the room in half.</p>
                <p>1. <strong>Left Room (Max Heap):</strong> Keeps all the shorter students. The "Tallest Short Kid" stands at the door.</p>
                <p>2. <strong>Right Room (Min Heap):</strong> Keeps all the taller students. The "Shortest Tall Kid" stands at the door.</p>
                <p>To find the median, you just look at the two kids standing at the doors. You don't care about anyone deep inside the rooms.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Two Heaps (Min/Max)</strong><br>
                1. <code>smallHeap</code> (Max Heap) stores the lower half of numbers.<br>
                2. <code>largeHeap</code> (Min Heap) stores the upper half.<br>
                3. Balance them so size difference is at most 1.<br>
                <em>Note: In TS/JS, we assume a PriorityQueue class exists (like in LeetCode) or use an array with binary insertion.</em>
            </div>

            <pre>
<span class="keyword">class</span> MedianFinder {
    <span class="comment">// Pseudo-code for Heaps (Assume MinPriorityQueue/MaxPriorityQueue exist)</span>
    minHeap: any; <span class="comment">// Large numbers</span>
    maxHeap: any; <span class="comment">// Small numbers</span>

    <span class="keyword">constructor</span>() {
        <span class="comment">// LEETCODE ENVIRONMENT SPECIFIC CLASSES</span>
        <span class="keyword">this</span>.minHeap = <span class="keyword">new</span> MinPriorityQueue();
        <span class="keyword">this</span>.maxHeap = <span class="keyword">new</span> MaxPriorityQueue();
    }

    <span class="func">addNum</span>(<span class="var">num</span>: number): void {
        <span class="comment">// 1. Add to Max Heap (Small side)</span>
        <span class="keyword">this</span>.maxHeap.enqueue(num);

        <span class="comment">// 2. Move biggest of Small side to Large side (Maintain order)</span>
        <span class="keyword">this</span>.minHeap.enqueue(<span class="keyword">this</span>.maxHeap.dequeue().element);

        <span class="comment">// 3. Balance sizes (Max Heap can have +1 element)</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.maxHeap.size() < <span class="keyword">this</span>.minHeap.size()) {
            <span class="keyword">this</span>.maxHeap.enqueue(<span class="keyword">this</span>.minHeap.dequeue().element);
        }
    }

    <span class="func">findMedian</span>(): number {
        <span class="keyword">if</span> (<span class="keyword">this</span>.maxHeap.size() > <span class="keyword">this</span>.minHeap.size()) {
            <span class="keyword">return</span> <span class="keyword">this</span>.maxHeap.front().element;
        }
        <span class="keyword">return</span> (<span class="keyword">this</span>.maxHeap.front().element + <span class="keyword">this</span>.minHeap.front().element) / 2;
    }
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            42. Clone Graph
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Architect's Blueprint"</div>
            <div class="eli5-box">
                <p>You are visiting a city (The Graph) and you want to build an exact replica on Mars.</p>
                <p>1. You land at House A. You build "Replica House A".</p>
                <p>2. House A connects to House B. You check your notebook: "Have I built Replica B yet?"</p>
                <p>3. If No: Go build Replica B. Record it in notebook. Then connect them.</p>
                <p>4. If Yes: Don't build it again! Just draw a wire connecting Replica A to the existing Replica B.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DFS + HashMap (Visited)</strong><br>
                Map stores <code>OldNode -> NewNode</code>.<br>
                If node is in Map, return the stored NewNode.<br>
                If not, create NewNode, store in Map, and recursively clone neighbors.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">cloneGraph</span>(<span class="var">node</span>: Node | null): Node | null {
    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="keyword">null</span>;

    <span class="keyword">const</span> oldToNew = <span class="keyword">new</span> Map&lt;Node, Node&gt;();

    <span class="keyword">function</span> dfs(curr: Node): Node {
        <span class="comment">// If already cloned, return the clone</span>
        <span class="keyword">if</span> (oldToNew.has(curr)) <span class="keyword">return</span> oldToNew.get(curr)!;

        <span class="comment">// Create clone and store IT IMMEDIATELY (to handle cycles)</span>
        <span class="keyword">const</span> copy = <span class="keyword">new</span> Node(curr.val);
        oldToNew.set(curr, copy);

        <span class="comment">// Clone neighbors</span>
        <span class="keyword">for</span> (<span class="keyword">const</span> neighbor <span class="keyword">of</span> curr.neighbors) {
            copy.neighbors.push(dfs(neighbor));
        }

        <span class="keyword">return</span> copy;
    }

    <span class="keyword">return</span> dfs(node);
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            43. Course Schedule
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Infinite Loop"</div>
            <div class="eli5-box">
                <p>You want to graduate.</p>
                <p>Rule: Math 101 requires Physics. Physics requires Math 101.</p>
                <p>Can you graduate? <strong>No.</strong> You are stuck in a cycle.</p>
                <p>We need to check every course to see if it leads to a cycle. <br>
                1. Start checking "Math". Mark it as "Visiting".<br>
                2. Check prerequisites. If you run into a course marked "Visiting", you found a loop!</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DFS Cycle Detection (Topological Sort logic)</strong><br>
                State 0: Unvisited.<br>
                State 1: Visiting (Currently in recursion stack).<br>
                State 2: Visited (Safe, verified no cycles here).<br>
                If DFS hits a node with State 1 -> Cycle Detected -> Return False.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">canFinish</span>(<span class="var">numCourses</span>: number, <span class="var">prerequisites</span>: number[][]): boolean {
    <span class="comment">// Build Adjacency List</span>
    <span class="keyword">const</span> preMap = <span class="keyword">new</span> Map&lt;number, number[]&gt;();
    <span class="keyword">for</span> (<span class="keyword">const</span> [course, pre] <span class="keyword">of</span> prerequisites) {
        <span class="keyword">if</span> (!preMap.has(course)) preMap.set(course, []);
        preMap.get(course)!.push(pre);
    }

    <span class="keyword">const</span> visiting = <span class="keyword">new</span> Set&lt;number&gt;(); <span class="comment">// State 1</span>

    <span class="keyword">function</span> dfs(course: number): boolean {
        <span class="keyword">if</span> (visiting.has(course)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Cycle detected</span>
        <span class="keyword">if</span> (!preMap.has(course)) <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">// No prereqs (Base case)</span>
        
        visiting.add(course); <span class="comment">// Mark as currently visiting</span>

        <span class="keyword">for</span> (<span class="keyword">const</span> pre <span class="keyword">of</span> preMap.get(course)!) {
            <span class="keyword">if</span> (!dfs(pre)) <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        visiting.delete(course); <span class="comment">// Unmark (Backtrack)</span>
        preMap.set(course, []);  <span class="comment">// Optimization: Mark as safe (empty prereqs)</span>
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < numCourses; i++) {
        <span class="keyword">if</span> (!dfs(i)) <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            44. Pacific Atlantic Water Flow
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Salmon Run"</div>
            <div class="eli5-box">
                <p>Imagine an island. Rain falls on top. Water flows DOWN to the ocean.</p>
                <p>Problem: It's hard to calculate "Where does water go?" for every single square.</p>
                <p><strong>Smart Solution:</strong> Reverse physics! Imagine "Salmon" climbing UP the mountain from the ocean.</p>
                <p>1. Send Salmon up from the Pacific (Top/Left edges). Mark everywhere they can reach.<br>
                2. Send Salmon up from the Atlantic (Bottom/Right edges). Mark everywhere they can reach.<br>
                3. Any square that has <strong>BOTH</strong> types of Salmon is your answer.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Multi-Source DFS (Reverse Flow)</strong><br>
                Instead of <code>Inner -> Outer</code>, go <code>Outer -> Inner</code>.<br>
                Condition: Water can only flow to a neighbor if <code>neighborHeight >= currentHeight</code> (because we are going uphill).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">pacificAtlantic</span>(<span class="var">heights</span>: number[][]): number[][] {
    <span class="keyword">const</span> ROWS = heights.length, COLS = heights[0].length;
    <span class="keyword">const</span> pacific = <span class="keyword">new</span> Set&lt;string&gt;();
    <span class="keyword">const</span> atlantic = <span class="keyword">new</span> Set&lt;string&gt;();

    <span class="keyword">function</span> dfs(r: number, c: number, visitSet: Set&lt;string&gt;, prevHeight: number) {
        <span class="keyword">if</span> (r < 0 || c < 0 || r >= ROWS || c >= COLS || 
            visitSet.has(`${r},${c}`) || heights[r][c] < prevHeight) {
            <span class="keyword">return</span>;
        }
        
        visitSet.add(`${r},${c}`);
        
        dfs(r + 1, c, visitSet, heights[r][c]);
        dfs(r - 1, c, visitSet, heights[r][c]);
        dfs(r, c + 1, visitSet, heights[r][c]);
        dfs(r, c - 1, visitSet, heights[r][c]);
    }

    <span class="comment">// 1. Start from Top/Bottom rows</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> c = 0; c < COLS; c++) {
        dfs(0, c, pacific, heights[0][c]);
        dfs(ROWS - 1, c, atlantic, heights[ROWS - 1][c]);
    }

    <span class="comment">// 2. Start from Left/Right cols</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < ROWS; r++) {
        dfs(r, 0, pacific, heights[r][0]);
        dfs(r, COLS - 1, atlantic, heights[r][COLS - 1]);
    }

    <span class="comment">// 3. Find intersection</span>
    <span class="keyword">const</span> res: number[][] = [];
    <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < ROWS; r++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> c = 0; c < COLS; c++) {
            <span class="keyword">if</span> (pacific.has(`${r},${c}`) && atlantic.has(`${r},${c}`)) {
                res.push([r, c]);
            }
        }
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            45. Number of Islands
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Godzilla Stomp"</div>
            <div class="eli5-box">
                <p>You have a map of Land (1) and Water (0). You want to count the islands.</p>
                <p>You are Godzilla. You iterate through the map.</p>
                <p>1. When you see Land ("1"), you roar "ISLAND FOUND!" (Count + 1).</p>
                <p>2. Then, you STOMP on that land, sinking it to the ocean (Turn "1" to "0").</p>
                <p>3. Because you are huge, the shockwave sinks all connected land (neighbors) too. You keep stomping until that entire island is gone.</p>
                <p>4. Then you move to the next square. Since you sunk the last island, you won't count it twice.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Grid DFS (Flood Fill)</strong><br>
                Iterate loops (r, c). If `grid[r][c] == '1'`, increment count, then call DFS.<br>
                DFS changes '1' to '0' (visited) and recurses to 4 directions.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">numIslands</span>(<span class="var">grid</span>: string[][]): number {
    <span class="keyword">if</span> (!grid || grid.length === 0) <span class="keyword">return</span> 0;

    <span class="keyword">const</span> ROWS = grid.length, COLS = grid[0].length;
    <span class="keyword">let</span> islands = 0;

    <span class="keyword">function</span> sinkIsland(r: number, c: number) {
        <span class="comment">// Bounds check + Water check</span>
        <span class="keyword">if</span> (r < 0 || c < 0 || r >= ROWS || c >= COLS || grid[r][c] === '0') {
            <span class="keyword">return</span>;
        }

        <span class="comment">// "Stomp" (Mark as visited/water)</span>
        grid[r][c] = '0';

        sinkIsland(r + 1, c);
        sinkIsland(r - 1, c);
        sinkIsland(r, c + 1);
        sinkIsland(r, c - 1);
    }

    <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < ROWS; r++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> c = 0; c < COLS; c++) {
            <span class="keyword">if</span> (grid[r][c] === '1') {
                islands++;
                sinkIsland(r, c);
            }
        }
    }

    <span class="keyword">return</span> islands;
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            46. Graph Valid Tree
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Perfect Circuit"</div>
            <div class="eli5-box">
                <p>You have some cities and some wires connecting them.</p>
                <p>A "Tree" means two things:</p>
                <ol>
                    <li><strong>No Loops:</strong> You can't walk in a circle.</li>
                    <li><strong>No Orphans:</strong> Every city must be connected to the main group.</li>
                </ol>
                <p><strong>The Test:</strong> Start at City 0. Walk everywhere you can. <br>
                1. Did you see the same city twice via a different path? (Loop! Fail).<br>
                2. After you stop walking, are there any cities you never visited? (Disconnected! Fail).</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DFS Cycle Detection + Connectivity Check</strong><br>
                Condition 1: A Tree with `n` nodes must have exactly `n - 1` edges.<br>
                Condition 2: A DFS starting from node 0 must visit `n` unique nodes (no disconnected parts).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">validTree</span>(<span class="var">n</span>: number, <span class="var">edges</span>: number[][]): boolean {
    <span class="comment">// Condition 1: Edge count must be n-1</span>
    <span class="keyword">if</span> (edges.length !== n - 1) <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="comment">// Build Graph</span>
    <span class="keyword">const</span> adj = <span class="keyword">new</span> Map&lt;number, number[]&gt;();
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < n; i++) adj.set(i, []);
    <span class="keyword">for</span> (<span class="keyword">const</span> [u, v] <span class="keyword">of</span> edges) {
        adj.get(u)!.push(v);
        adj.get(v)!.push(u);
    }

    <span class="keyword">const</span> visit = <span class="keyword">new</span> Set&lt;number&gt;();

    <span class="keyword">function</span> dfs(node: number, parent: number): boolean {
        <span class="keyword">if</span> (visit.has(node)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Loop detected</span>
        
        visit.add(node);

        <span class="keyword">for</span> (<span class="keyword">const</span> neighbor <span class="keyword">of</span> adj.get(node)!) {
            <span class="keyword">if</span> (neighbor === parent) <span class="keyword">continue</span>; <span class="comment">// Don't go back to where we came from</span>
            <span class="keyword">if</span> (!dfs(neighbor, node)) <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// Condition 2: No cycles and Connected</span>
    <span class="comment">// We start at 0. If true, verify we visited all 'n' nodes.</span>
    <span class="keyword">return</span> dfs(0, -1) && visit.size === n;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            47. Number of Connected Components
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Team Captains"</div>
            <div class="eli5-box">
                <p>You have 100 people. Some are friends. Friends form a "Component" (a clique).</p>
                <p>We want to count how many cliques exist.</p>
                <p><strong>The Strategy (Union Find):</strong> Everyone starts as their own Captain. <br>
                When Person A becomes friends with Person B, one of them stops being a Captain and joins the other's team.</p>
                <p>Every time you merge two teams, the number of total teams goes down by 1.</p>
                <p>Start with 100 teams. Perform merges. Result = Remaining Teams.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Union Find (Disjoint Set Union)</strong><br>
                1. `parent` array: `parent[i] = i` initially.<br>
                2. `find(i)`: Returns the representative (Captain) of `i` (with path compression).<br>
                3. `union(i, j)`: Connects two captains. Decrements global count `res`.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">countComponents</span>(<span class="var">n</span>: number, <span class="var">edges</span>: number[][]): number {
    <span class="keyword">const</span> parent = <span class="keyword">new</span> Array(n).fill(0).map((_, i) => i);
    <span class="keyword">const</span> rank = <span class="keyword">new</span> Array(n).fill(1);
    <span class="keyword">let</span> res = n;

    <span class="comment">// Find Captain</span>
    <span class="keyword">function</span> find(n: number): number {
        <span class="keyword">let</span> p = parent[n];
        <span class="keyword">while</span> (p !== parent[p]) {
            parent[p] = parent[parent[p]]; <span class="comment">// Path compression</span>
            p = parent[p];
        }
        <span class="keyword">return</span> p;
    }

    <span class="comment">// Merge Teams</span>
    <span class="keyword">function</span> union(n1: number, n2: number): number {
        <span class="keyword">const</span> p1 = find(n1);
        <span class="keyword">const</span> p2 = find(n2);

        <span class="keyword">if</span> (p1 === p2) <span class="keyword">return</span> 0; <span class="comment">// Already same team</span>

        <span class="comment">// Union by Rank (Attach small tree to big tree)</span>
        <span class="keyword">if</span> (rank[p1] > rank[p2]) {
            parent[p2] = p1;
            rank[p1] += rank[p2];
        } <span class="keyword">else</span> {
            parent[p1] = p2;
            rank[p2] += rank[p1];
        }
        <span class="keyword">return</span> 1;
    }

    <span class="keyword">for</span> (<span class="keyword">const</span> [n1, n2] <span class="keyword">of</span> edges) {
        res -= union(n1, n2);
    }

    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            48. Alien Dictionary
            <span class="difficulty" style="background: rgba(239, 68, 68, 0.2); color: #fecaca;">Hard</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Language Decoder"</div>
            <div class="eli5-box">
                <p>You find an ancient book. The words are sorted, but the alphabet order is unknown.</p>
                <p>Word 1: "WRT"<br>Word 2: "WRF"</p>
                <p>Since "WRT" comes before "WRF", and the first two letters are the same, that means <strong>T comes before F</strong>.</p>
                <p>You collect all these rules ("T before F", "W before E"...). Then you line them up in a way that breaks no rules.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Topological Sort (Post-Order DFS)</strong><br>
                1. Build adjacency list (DAG) by comparing adjacent words.<br>
                2. Run DFS to find order.<br>
                3. Detect cycles (if T < F and F < T, the language is invalid).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">alienOrder</span>(<span class="var">words</span>: string[]): string {
    <span class="keyword">const</span> adj = <span class="keyword">new</span> Map&lt;string, string[]&gt;();
    
    <span class="comment">// Init Nodes</span>
    <span class="keyword">for</span> (<span class="keyword">const</span> w <span class="keyword">of</span> words) {
        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> w) adj.set(c, []);
    }

    <span class="comment">// Build Rules</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < words.length - 1; i++) {
        <span class="keyword">const</span> w1 = words[i], w2 = words[i + 1];
        <span class="keyword">const</span> minLen = Math.min(w1.length, w2.length);
        
        <span class="comment">// Edge case: "apple", "app" -> Invalid (prefix should come first)</span>
        <span class="keyword">if</span> (w1.length > w2.length && w1.slice(0, minLen) === w2.slice(0, minLen)) {
            <span class="keyword">return</span> "";
        }

        <span class="keyword">for</span> (<span class="keyword">let</span> j = 0; j < minLen; j++) {
            <span class="keyword">if</span> (w1[j] !== w2[j]) {
                adj.get(w1[j])!.push(w2[j]);
                <span class="keyword">break</span>; <span class="comment">// Only the first different char determines order</span>
            }
        }
    }

    <span class="comment">// Topo Sort</span>
    <span class="keyword">const</span> visited = <span class="keyword">new</span> Map&lt;string, boolean&gt;(); <span class="comment">// False=Visited, True=CurrentPath</span>
    <span class="keyword">const</span> res: string[] = [];

    <span class="keyword">function</span> dfs(char: string): boolean {
        <span class="keyword">if</span> (visited.has(char)) <span class="keyword">return</span> visited.get(char)!; <span class="comment">// Cycle if true</span>
        
        visited.set(char, <span class="keyword">true</span>); <span class="comment">// Mark visiting</span>
        
        <span class="keyword">for</span> (<span class="keyword">const</span> neighbor <span class="keyword">of</span> adj.get(char)!) {
            <span class="keyword">if</span> (dfs(neighbor)) <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        visited.set(char, <span class="keyword">false</span>); <span class="comment">// Mark visited</span>
        res.push(char);
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> adj.keys()) {
        <span class="keyword">if</span> (dfs(c)) <span class="keyword">return</span> ""; <span class="comment">// Cycle detected</span>
    }

    <span class="keyword">return</span> res.reverse().join("");
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            49. Meeting Rooms
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Calendar Check"</div>
            <div class="eli5-box">
                <p>You have a list of meeting times: `[9-10], [11-12], [9:30-10:30]`.</p>
                <p>Can you attend ALL of them?</p>
                <p><strong>The Strategy:</strong> SORT THEM BY START TIME.</p>
                <p>Sorted: `[9-10], [9:30-10:30], [11-12]`.</p>
                <p>Now just look at pairs. Meeting 1 ends at 10. Meeting 2 starts at 9:30. <br>
                Since 9:30 < 10, they crash. You cannot attend both.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Intervals (Sorting)</strong><br>
                1. Sort by `start` time.<br>
                2. Check `if (currentStart < previousEnd)`. Return false immediately if overlap found.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">canAttendMeetings</span>(<span class="var">intervals</span>: number[][]): boolean {
    <span class="comment">// 1. Sort by Start Time</span>
    intervals.sort((a, b) => a[0] - b[0]);

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i < intervals.length; i++) {
        <span class="keyword">const</span> prevEnd = intervals[i - 1][1];
        <span class="keyword">const</span> currStart = intervals[i][0];

        <span class="comment">// 2. Overlap check</span>
        <span class="keyword">if</span> (currStart < prevEnd) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            50. Meeting Rooms II
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Office Manager"</div>
            <div class="eli5-box">
                <p>Same meetings as before. Now, you are the Office Manager. You can't cancel meetings.</p>
                <p>Question: What is the <strong>minimum number of rooms</strong> we need to rent so that everyone has a space?</p>
                <p><strong>Strategy (Chronological):</strong> Treat Start Times as "People Walking In" and End Times as "People Walking Out".</p>
                <p>Sort all Starts. Sort all Ends.</p>
                <p>Walk through the timeline. <br>
                - Someone walks in? Count++ (Need room).<br>
                - Someone walks out? Count-- (Room freed).<br>
                - Track the <strong>Highest Count</strong> you ever reached.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Chronological Ordering (Two Pointer)</strong><br>
                Separate start and end times into two sorted arrays.<br>
                If `start[s] < end[e]`, a meeting started before one finished -> Count++.<br>
                If `start[s] >= end[e]`, a meeting finished -> Count--.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">minMeetingRooms</span>(<span class="var">intervals</span>: number[][]): number {
    <span class="keyword">const</span> starts = intervals.map(i => i[0]).sort((a, b) => a - b);
    <span class="keyword">const</span> ends = intervals.map(i => i[1]).sort((a, b) => a - b);

    <span class="keyword">let</span> count = 0;
    <span class="keyword">let</span> maxCount = 0;
    <span class="keyword">let</span> s = 0, e = 0;

    <span class="keyword">while</span> (s < intervals.length) {
        <span class="comment">// A meeting starts before the earliest meeting ends</span>
        <span class="keyword">if</span> (starts[s] < ends[e]) {
            count++;
            s++;
        } 
        <span class="comment">// A meeting ended</span>
        <span class="keyword">else</span> {
            count--;
            e++;
        }
        maxCount = Math.max(maxCount, count);
    }
    <span class="keyword">return</span> maxCount;
}</pre>
        </div>
    </div>
    <div class="pattern-group" style="margin-top: 60px;">
        <h1>Set 3: Optimization (DP & Greedy)</h1>
        <p>Focus: Mathematical efficiency and decision making.</p>
    </div>

    <div class="problem-card">
        <div class="header">
            51. Insert Interval
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Sticky Note"</div>
            <div class="eli5-box">
                <p>You have a timeline of clean, separate sticky notes: <code>[1-3], [6-9]</code>.</p>
                <p>You want to stick a new note <code>[2-5]</code> on top.</p>
                <p><strong>The Process:</strong></p>
                <ol>
                    <li><strong>Left Side:</strong> Any note that ends before your new note starts is safe. Keep them. (<code>[1-3]</code>? Wait, 3 overlaps with 2. Not safe).</li>
                    <li><strong>The Merge:</strong> Any note that touches your new note gets absorbed. <br>
                    New Note starts at 2. Old Note 1-3 starts at 1. Combine them! New start is 1.<br>
                    New Note ends at 5. Old Note 1-3 ends at 3. Combine! New end is 5. Result: <code>[1-5]</code>.</li>
                    <li><strong>Right Side:</strong> Any note that starts after your new blob finishes is safe. Keep them.</li>
                </ol>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Linear Scan (Left, Merge, Right)</strong><br>
                1. Push all intervals ending <em>before</em> `newInterval.start`.<br>
                2. Merge all overlapping intervals: `newStart = min(s1, s2)`, `newEnd = max(e1, e2)`.<br>
                3. Push the merged interval.<br>
                4. Push all intervals starting <em>after</em> `newInterval.end`.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">insert</span>(<span class="var">intervals</span>: number[][], <span class="var">newInterval</span>: number[]): number[][] {
    <span class="keyword">const</span> res: number[][] = [];
    <span class="keyword">let</span> i = 0;
    <span class="keyword">const</span> n = intervals.length;

    <span class="comment">// 1. Left (No overlap)</span>
    <span class="keyword">while</span> (i < n && intervals[i][1] < newInterval[0]) {
        res.push(intervals[i]);
        i++;
    }

    <span class="comment">// 2. Merge (Overlap exists)</span>
    <span class="comment">// While current interval starts before newInterval ends</span>
    <span class="keyword">while</span> (i < n && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    res.push(newInterval);

    <span class="comment">// 3. Right (No overlap)</span>
    <span class="keyword">while</span> (i < n) {
        res.push(intervals[i]);
        i++;
    }

    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            52. Merge Intervals
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Puddle" Theory</div>
            <div class="eli5-box">
                <p>Imagine rain puddles on a sidewalk. <code>[1-3]</code> is a puddle. <code>[2-6]</code> is a puddle.</p>
                <p>Because they overlap (2 is between 1 and 3), they merge into one giant puddle <code>[1-6]</code>.</p>
                <p><strong>Strategy:</strong> Sort the puddles by their starting position. Then walk through them. If the current puddle starts <em>before</em> the previous one ends, they are connected. Extend the previous puddle.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Sorting + One Pass</strong><br>
                Sort by start time. Initialize result with the first interval.<br>
                Compare `current.start` with `lastResult.end`.<br>
                Overlap? Update `lastResult.end = max(lastResult.end, current.end)`.<br>
                No Overlap? Push `current`.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">merge</span>(<span class="var">intervals</span>: number[][]): number[][] {
    <span class="comment">// 1. Sort by start time</span>
    intervals.sort((a, b) => a[0] - b[0]);

    <span class="keyword">const</span> res: number[][] = [intervals[0]];

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i < intervals.length; i++) {
        <span class="keyword">const</span> last = res[res.length - 1];
        <span class="keyword">const</span> curr = intervals[i];

        <span class="comment">// Overlap Check</span>
        <span class="keyword">if</span> (curr[0] <= last[1]) {
            <span class="comment">// Merge by extending the end time</span>
            last[1] = Math.max(last[1], curr[1]);
        } <span class="keyword">else</span> {
            <span class="comment">// No overlap, add as new puddle</span>
            res.push(curr);
        }
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            53. Non-overlapping Intervals
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Greedy Scheduler"</div>
            <div class="eli5-box">
                <p>You want to attend as many meetings as possible. But you have two meetings that clash.</p>
                <p>Meeting A: 9:00 - 10:00<br>Meeting B: 9:30 - 14:00 (Very long!)</p>
                <p>Which one should you cancel? <strong>Cancel B.</strong></p>
                <p>Why? Because removing B frees up time from 10:00 to 14:00, allowing you to fit 3 more meetings later. Removing A only frees up 30 minutes. Always remove the meeting that ends <strong>later</strong>.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Greedy (Remove Longest End Time)</strong><br>
                Sort by start time.<br>
                If overlap occurs (`curr.start < prev.end`):<br>
                1. Increment `removeCount`.<br>
                2. Keep the interval with the <strong>smaller end time</strong> (Update `prev.end = min(prev.end, curr.end)`). This leaves more room for future intervals.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">eraseOverlapIntervals</span>(<span class="var">intervals</span>: number[][]): number {
    intervals.sort((a, b) => a[0] - b[0]);

    <span class="keyword">let</span> res = 0;
    <span class="keyword">let</span> prevEnd = intervals[0][1];

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i < intervals.length; i++) {
        <span class="keyword">const</span> start = intervals[i][0];
        <span class="keyword">const</span> end = intervals[i][1];

        <span class="keyword">if</span> (start < prevEnd) {
            <span class="comment">// Overlap! Must remove one.</span>
            res++;
            <span class="comment">// Greedily keep the one that ends sooner</span>
            prevEnd = Math.min(prevEnd, end);
        } <span class="keyword">else</span> {
            <span class="comment">// No overlap, just update pointer</span>
            prevEnd = end;
        }
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            54. Climbing Stairs (Introduction to DP)
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Robot Legs"</div>
            <div class="eli5-box">
                <p>You are a robot. You can jump 1 step or 2 steps.</p>
                <p>To reach Step 10, where could you have come from?</p>
                <ul>
                    <li>You jumped 1 step from Step 9.</li>
                    <li>OR, you jumped 2 steps from Step 8.</li>
                </ul>
                <p>So, <code>Ways(10) = Ways(9) + Ways(8)</code>.</p>
                <p>Wait... this is just the Fibonacci sequence (1, 1, 2, 3, 5, 8...).</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: 1D Dynamic Programming</strong><br>
                Formula: `dp[i] = dp[i-1] + dp[i-2]`.<br>
                Since we only need the last two numbers, we don't need a whole array. We just need two variables `one` and `two` to save space (O(1) space).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">climbStairs</span>(<span class="var">n</span>: number): number {
    <span class="keyword">let</span> one = 1; <span class="comment">// Ways to reach step n-1</span>
    <span class="keyword">let</span> two = 1; <span class="comment">// Ways to reach step n-2</span>

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < n - 1; i++) {
        <span class="keyword">const</span> temp = one;
        one = one + two;
        two = temp;
    }
    <span class="keyword">return</span> one;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            55. Coin Change
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Vending Machine"</div>
            <div class="eli5-box">
                <p>You want to buy a toy for 11 cents. You have coins: 1, 2, 5.</p>
                <p>You want to use the <strong>fewest coins possible</strong>.</p>
                <p>You ask the machine: "What is the best way to make 11?"</p>
                <p>The machine thinks: "If I use a 5-cent coin, I need to solve 'How to make 6'. If I use another 5, I need to solve 'How to make 1'. That's easy!"</p>
                <p>It solves the problem <strong>Bottom-Up</strong>. <br>
                0 cents = 0 coins.<br>
                1 cent = 1 coin (1).<br>
                2 cents = 1 coin (2) OR 2 coins (1+1). 1 is better.<br>
                ... all the way to 11.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DP - Unbounded Knapsack</strong><br>
                Create array `dp` of size `amount + 1` filled with Infinity.<br>
                `dp[0] = 0`.<br>
                Loop from 1 to Amount. For each amount, try every coin.<br>
                Formula: `dp[a] = min(dp[a], 1 + dp[a - coin])`.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">coinChange</span>(<span class="var">coins</span>: number[], <span class="var">amount</span>: number): number {
    <span class="comment">// Fill with amount + 1 (representing Infinity/Impossible)</span>
    <span class="keyword">const</span> dp = <span class="keyword">new</span> Array(amount + 1).fill(amount + 1);
    
    dp[0] = 0; <span class="comment">// Base case: 0 coins to make 0 amount</span>

    <span class="keyword">for</span> (<span class="keyword">let</span> a = 1; a <= amount; a++) {
        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> coins) {
            <span class="keyword">if</span> (a - c >= 0) {
                <span class="comment">// 1 (current coin) + best way to make remainder</span>
                dp[a] = Math.min(dp[a], 1 + dp[a - c]);
            }
        }
    }

    <span class="keyword">return</span> dp[amount] > amount ? -1 : dp[amount];
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            56. Longest Increasing Subsequence
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Stepping Stones"</div>
            <div class="eli5-box">
                <p>You are crossing a river on numbered stones: <code>[10, 9, 2, 5, 3, 7]</code>.</p>
                <p><strong>Rule:</strong> You can only jump to a stone with a <strong>higher number</strong> than the one you are standing on.</p>
                <p>To find the max jumps ending at stone "7", you look back at all previous stones.</p>
                <p>"Could I have come from stone 2? Yes (2 < 7). If the path to 2 was 1 jump, my path is 1+1 = 2."</p>
                <p>"Could I have come from stone 5? Yes (5 < 7). If path to 5 was 2 jumps (2->5), my path is 2+1 = 3."</p>
                <p>You pick the best history and add 1.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DP O(NÂ²)</strong><br>
                <code>dp[i]</code> = Length of LIS ending at index i.<br>
                Loop i from 0 to N. Loop j from 0 to i.<br>
                If <code>nums[i] > nums[j]</code>, we can extend that chain: <code>dp[i] = max(dp[i], 1 + dp[j])</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">lengthOfLIS</span>(<span class="var">nums</span>: number[]): number {
    <span class="comment">// Base case: Every single number is a subsequence of length 1</span>
    <span class="keyword">const</span> dp = <span class="keyword">new</span> Array(nums.length).fill(1);
    <span class="keyword">let</span> maxLen = 1;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i < nums.length; i++) {
        <span class="comment">// Check every previous number</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> j = 0; j < i; j++) {
            <span class="keyword">if</span> (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], 1 + dp[j]);
            }
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    <span class="keyword">return</span> maxLen;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            57. Longest Common Subsequence
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Text Message" Game</div>
            <div class="eli5-box">
                <p>Alice sends: "ABCDE". Bob receives: "ACE".</p>
                <p>What is the longest sequence of letters that arrived in the correct order?</p>
                <p>Imagine a Grid. Alice is the rows, Bob is the columns.</p>
                <p>1. If letters match (e.g., 'A' == 'A'), we score a point! <strong>1 + result from diagonal</strong> (removing both A's).</p>
                <p>2. If they don't match, we have a choice: Ignore Alice's letter OR Ignore Bob's letter. We pick the <strong>Max</strong> of those two futures.</p>
            </div>
            

[Image of longest common subsequence table]


            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: 2D DP Grid</strong><br>
                <code>dp[r][c]</code> stores LCS for text1 starting at r and text2 starting at c.<br>
                Match: <code>1 + dp[r+1][c+1]</code>.<br>
                Mismatch: <code>Math.max(dp[r+1][c], dp[r][c+1])</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">longestCommonSubsequence</span>(<span class="var">text1</span>: string, <span class="var">text2</span>: string): number {
    <span class="comment">// Create grid (Rows+1 x Cols+1) filled with 0</span>
    <span class="keyword">const</span> dp: number[][] = Array(text1.length + 1)
        .fill(0).map(() => Array(text2.length + 1).fill(0));

    <span class="comment">// Iterate Bottom-Up</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = text1.length - 1; i >= 0; i--) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = text2.length - 1; j >= 0; j--) {
            <span class="keyword">if</span> (text1[i] === text2[j]) {
                <span class="comment">// Match: 1 + Diagonal</span>
                dp[i][j] = 1 + dp[i + 1][j + 1];
            } <span class="keyword">else</span> {
                <span class="comment">// No Match: Max(Right, Down)</span>
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
            }
        }
    }
    <span class="keyword">return</span> dp[0][0];
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            58. Word Break
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Chopping Board"</div>
            <div class="eli5-box">
                <p>String: "applepenapple". Dictionary: ["apple", "pen"].</p>
                <p>Can you chop this string so EVERY slice is a valid word?</p>
                <p>Start from the back. <br>
                - Can I chop off "apple"? Yes. Remainder: "applepen".<br>
                - Can I chop off "pen"? Yes. Remainder: "apple".<br>
                - Can I chop off "apple"? Yes. Remainder: "" (Success!).</p>
                <p>If you reach the empty string, you win.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: DP (Memoization)</strong><br>
                <code>dp[i]</code> = boolean: Can the string starting at index <code>i</code> be segmented?<br>
                Iterate <code>i</code> backwards. For each <code>i</code>, try matching every word in dictionary.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">wordBreak</span>(<span class="var">s</span>: string, <span class="var">wordDict</span>: string[]): boolean {
    <span class="keyword">const</span> dp = <span class="keyword">new</span> Array(s.length + 1).fill(<span class="keyword">false</span>);
    dp[s.length] = <span class="keyword">true</span>; <span class="comment">// Base case: End of string is valid</span>

    <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length - 1; i >= 0; i--) {
        <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> wordDict) {
            <span class="comment">// 1. Does the word fit?</span>
            <span class="comment">// 2. Do the chars match?</span>
            <span class="keyword">if</span> (i + word.length <= s.length && 
                s.slice(i, i + word.length) === word) {
                
                <span class="comment">// If match, inherit validity from the slice after this word</span>
                dp[i] = dp[i + word.length];
            }
            <span class="keyword">if</span> (dp[i]) <span class="keyword">break</span>; <span class="comment">// Optimization: Found one valid word here, move on</span>
        }
    }
    <span class="keyword">return</span> dp[0];
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            59. Combination Sum
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Unlimited Coins"</div>
            <div class="eli5-box">
                <p>Target: 7. Coins: [2, 3, 6, 7].</p>
                <p>You have an infinite supply of each coin.</p>
                <p>At every step, you stand at a fork in the road:</p>
                <ol>
                    <li><strong>Take:</strong> Pick coin [2]. Target becomes 5. <strong>Stay at coin [2]</strong> (because you can pick it again!).</li>
                    <li><strong>Skip:</strong> Don't pick coin [2]. Move to coin [3]. You can NEVER pick [2] again for this path.</li>
                </ol>
            </div>
            

[Image of backtracking algorithm tree]


            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Backtracking (Decision Tree)</strong><br>
                DFS function with arguments <code>(index, currentTotal, currentPath)</code>.<br>
                Branch 1 (Include): Add <code>nums[i]</code> to path. Recurse with same index <code>i</code>.<br>
                Branch 2 (Exclude): Don't add. Recurse with <code>i + 1</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">combinationSum</span>(<span class="var">candidates</span>: number[], <span class="var">target</span>: number): number[][] {
    <span class="keyword">const</span> res: number[][] = [];

    <span class="keyword">function</span> dfs(i: number, cur: number[], total: number) {
        <span class="comment">// 1. Success</span>
        <span class="keyword">if</span> (total === target) {
            res.push([...cur]); <span class="comment">// Copy the array</span>
            <span class="keyword">return</span>;
        }
        <span class="comment">// 2. Failure (Overshot or no coins left)</span>
        <span class="keyword">if</span> (i >= candidates.length || total > target) {
            <span class="keyword">return</span>;
        }

        <span class="comment">// Decision 1: INCLUDE candidates[i]</span>
        cur.push(candidates[i]);
        <span class="comment">// Note: passing 'i' again allows reuse of same number</span>
        dfs(i, cur, total + candidates[i]);

        <span class="comment">// Backtrack (clean up for Decision 2)</span>
        cur.pop();

        <span class="comment">// Decision 2: EXCLUDE candidates[i] (Move to next number)</span>
        dfs(i + 1, cur, total);
    }

    dfs(0, [], 0);
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            60. House Robber
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Alarm System"</div>
            <div class="eli5-box">
                <p>Street: <code>[Money1, Money2, Money3, Money4]</code>.</p>
                <p>Rule: If you rob two houses next to each other, the alarm goes off.</p>
                <p>At House 3, you ask: "What is the most I can have right now?"</p>
                <ul>
                    <li>Option A: Rob House 3 + (Max money from House 1).</li>
                    <li>Option B: Skip House 3 + (Max money from House 2).</li>
                </ul>
                <p>You pick the max of A or B.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: 1D DP</strong><br>
                Formula: <code>rob = max(arr[i] + rob[i-2], rob[i-1])</code>.<br>
                We only need two variables to store history: `rob1` (i-2) and `rob2` (i-1).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">rob</span>(<span class="var">nums</span>: number[]): number {
    <span class="keyword">let</span> rob1 = 0; <span class="comment">// Max loot from 2 houses ago</span>
    <span class="keyword">let</span> rob2 = 0; <span class="comment">// Max loot from 1 house ago</span>

    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> nums) {
        <span class="comment">// New Max = max(Current + 2_Ago, 1_Ago)</span>
        <span class="keyword">const</span> temp = Math.max(n + rob1, rob2);
        
        <span class="comment">// Shift forward</span>
        rob1 = rob2;
        rob2 = temp;
    }
    <span class="keyword">return</span> rob2;
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            61. House Robber II (Circular)
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Cul-de-Sac"</div>
            <div class="eli5-box">
                <p>This is the same as House Robber I, but the street is a <strong>Circle</strong>.</p>
                <p><strong>The Catch:</strong> House #1 and the Last House are neighbors. You cannot rob both.</p>
                <p><strong>The Strategy:</strong> You can't break the circle easily. So, you create two parallel universes:</p>
                <ol>
                    <li><strong>Universe A:</strong> You ignore the First House completely. (Rob Houses 2 to End).</li>
                    <li><strong>Universe B:</strong> You ignore the Last House completely. (Rob Houses 1 to End-1).</li>
                </ol>
                <p>Solve both universes using the old logic. Pick the winner.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Breaking Cycles + Reuse Logic</strong><br>
                Solution = `max( rob(nums[1:]), rob(nums[:-1]) )`.<br>
                 Reuse the helper function from Q60.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">rob2</span>(<span class="var">nums</span>: number[]): number {
    <span class="keyword">if</span> (nums.length === 0) <span class="keyword">return</span> 0;
    <span class="keyword">if</span> (nums.length === 1) <span class="keyword">return</span> nums[0];

    <span class="comment">// Helper from Q60 (House Robber 1)</span>
    <span class="keyword">function</span> robLinear(arr: number[]): number {
        <span class="keyword">let</span> rob1 = 0, rob2 = 0;
        <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> arr) {
            <span class="keyword">const</span> temp = Math.max(n + rob1, rob2);
            rob1 = rob2;
            rob2 = temp;
        }
        <span class="keyword">return</span> rob2;
    }

    <span class="comment">// Compare Universe A vs Universe B</span>
    <span class="keyword">return</span> Math.max(
        robLinear(nums.slice(0, nums.length - 1)), <span class="comment">// Skip Last</span>
        robLinear(nums.slice(1))                   <span class="comment">// Skip First</span>
    );
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            62. Unique Paths
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Robot Grid"</div>
            <div class="eli5-box">
                <p>A robot starts at Top-Left. It wants to go to Bottom-Right.</p>
                <p>Rules: Only move <strong>Down</strong> or <strong>Right</strong>.</p>
                <p>Stand at any square. How many ways could you have arrived here?</p>
                <p>Answer: (Ways to reach the square Above me) + (Ways to reach the square Left of me).</p>
                <p>This is basically Pascal's Triangle on a grid.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: 2D Dynamic Programming</strong><br>
                Equation: `grid[r][c] = grid[r-1][c] + grid[r][c-1]`.<br>
                Optimization: You only need the previous row to calculate the current row, so you can reduce space from O(M*N) to O(N).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">uniquePaths</span>(<span class="var">m</span>: number, <span class="var">n</span>: number): number {
    <span class="comment">// Optimization: Just keep one row of history</span>
    <span class="keyword">let</span> row = <span class="keyword">new</span> Array(n).fill(1);

    <span class="comment">// Iterate through all other rows</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < m - 1; i++) {
        <span class="keyword">const</span> newRow = <span class="keyword">new</span> Array(n).fill(1);
        <span class="comment">// Compute new row based on Left + Top (which is 'row')</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> j = 1; j < n; j++) {
            newRow[j] = newRow[j - 1] + row[j];
        }
        row = newRow;
    }
    <span class="keyword">return</span> row[n - 1];
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            63. Decode Ways
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Spy Message"</div>
            <div class="eli5-box">
                <p>Code: A=1, B=2 ... Z=26. Message: "12".</p>
                <p>Is this "AB" (1, 2)? OR is it "L" (12)?</p>
                <p>You iterate through the string. At every digit, you check:</p>
                <ol>
                    <li><strong>Single Digit:</strong> Is "1" valid? Yes. Add previous ways.</li>
                    <li><strong>Double Digit:</strong> Is "12" valid (10-26)? Yes. Add ways from 2 steps ago.</li>
                </ol>
                <p><strong>Trap:</strong> "0" is evil. "0" alone is invalid. "06" is invalid. Only "10" or "20" works.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: 1D DP (Fibonacci Variant)</strong><br>
                `dp[i]` depends on `dp[i-1]` (if s[i] != '0') AND `dp[i-2]` (if s[i-1..i] is 10-26).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">numDecodings</span>(<span class="var">s</span>: string): number {
    <span class="keyword">if</span> (s[0] === '0') <span class="keyword">return</span> 0;

    <span class="keyword">let</span> twoBack = 1; <span class="comment">// Ways to decode string ending 2 steps back</span>
    <span class="keyword">let</span> oneBack = 1; <span class="comment">// Ways to decode string ending 1 step back</span>

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i < s.length; i++) {
        <span class="keyword">let</span> current = 0;

        <span class="comment">// 1. Single Digit Check (1-9)</span>
        <span class="keyword">if</span> (s[i] !== '0') {
            current += oneBack;
        }

        <span class="comment">// 2. Double Digit Check (10-26)</span>
        <span class="keyword">const</span> twoDigit = parseInt(s.substring(i - 1, i + 1));
        <span class="keyword">if</span> (twoDigit >= 10 && twoDigit <= 26) {
            current += twoBack;
        }

        twoBack = oneBack;
        oneBack = current;
    }
    <span class="keyword">return</span> oneBack;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            64. Jump Game
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Finish Line"</div>
            <div class="eli5-box">
                <p>You are standing at Index 0. <code>nums[i]</code> is how much gas (jump distance) you get at that spot.</p>
                <p>Can you reach the End?</p>
                <p><strong>The Trick:</strong> Don't simulate jumping forward (too many paths). <strong>Walk Backwards.</strong></p>
                <p>Move the Finish Line closer. If I am at index 3 and I can jump to the Finish Line, then Index 3 becomes the new Finish Line.</p>
                <p>If the Finish Line reaches 0, we win.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Greedy (Backwards)</strong><br>
                Initialize `goal = lastIndex`.<br>
                Iterate backwards. If `i + nums[i] >= goal`, then `goal = i`.<br>
                Return `goal === 0`.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">canJump</span>(<span class="var">nums</span>: number[]): boolean {
    <span class="keyword">let</span> goal = nums.length - 1;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - 2; i >= 0; i--) {
        <span class="comment">// Can I reach the current goal from here?</span>
        <span class="keyword">if</span> (i + nums[i] >= goal) {
            <span class="comment">// Yes! Move the goal post closer to start</span>
            goal = i;
        }
    }

    <span class="keyword">return</span> goal === 0;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            65. Rotate Image (Matrix)
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Geometry Trick"</div>
            <div class="eli5-box">
                <p>You want to rotate a square picture 90 degrees clockwise.</p>
                <p>Trying to move pixels one by one is a headache (Index math is hard).</p>
                <p><strong>The Magic Two-Step:</strong></p>
                <ol>
                    <li><strong>Transpose:</strong> Swap rows and columns. (The top-right corner becomes bottom-left). It creates a mirror image across the diagonal.</li>
                    <li><strong>Reverse Rows:</strong> Flip every row horizontally (Left becomes Right).</li>
                </ol>
                <p>Result: Perfectly rotated image.</p>
            </div>
            

[Image of matrix rotation 90 degrees]


            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Transpose + Reverse</strong><br>
                1. Loop `i` and `j` (where `j > i`) to swap `m[i][j]` with `m[j][i]`.<br>
                2. Loop `row` and reverse it.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">rotate</span>(<span class="var">matrix</span>: number[][]): void {
    <span class="keyword">const</span> n = matrix.length;

    <span class="comment">// 1. Transpose (Swap [i][j] with [j][i])</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < n; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j < n; j++) {
            <span class="keyword">const</span> temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    <span class="comment">// 2. Reverse each row</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < n; i++) {
        matrix[i].reverse();
    }
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            66. Set Matrix Zeroes
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Infection"</div>
            <div class="eli5-box">
                <p>You have a grid. If a cell has a virus (0), it infects its entire Row and Column (turns them to 0).</p>
                <p><strong>The Trap:</strong> If you start changing 1s to 0s immediately, you will get confused later. "Wait, was this 0 original? Or did I just change it?" You might end up turning the <em>entire</em> board to zero.</p>
                <p><strong>The Solution:</strong> Use the First Row and First Column as a "Notepad".</p>
                <p>If you see a 0 at `[2][5]`, go mark `Row 2` header as 0, and `Col 5` header as 0. Do the rest later.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: In-Place State Storage</strong><br>
                Use `matrix[r][0]` and `matrix[0][c]` as flags.<br>
                1. Loop through grid. If `cell == 0`, mark the row header and col header.<br>
                2. Loop through grid again (skipping headers). If header says 0, turn cell to 0.<br>
                3. Handle the headers (Row 0 / Col 0) separately at the end.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">setZeroes</span>(<span class="var">matrix</span>: number[][]): void {
    <span class="keyword">const</span> R = matrix.length, C = matrix[0].length;
    <span class="keyword">let</span> firstRowZero = <span class="keyword">false</span>;

    <span class="comment">// 1. Mark headers</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < R; r++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> c = 0; c < C; c++) {
            <span class="keyword">if</span> (matrix[r][c] === 0) {
                matrix[0][c] = 0; <span class="comment">// Mark Column header</span>
                
                <span class="keyword">if</span> (r > 0) matrix[r][0] = 0; <span class="comment">// Mark Row header</span>
                <span class="keyword">else</span> firstRowZero = <span class="keyword">true</span>;    <span class="comment">// Special flag for Row 0 itself</span>
            }
        }
    }

    <span class="comment">// 2. Use headers to set inner cells</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> r = 1; r < R; r++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> c = 1; c < C; c++) {
            <span class="keyword">if</span> (matrix[0][c] === 0 || matrix[r][0] === 0) {
                matrix[r][c] = 0;
            }
        }
    }

    <span class="comment">// 3. Fix First Col</span>
    <span class="keyword">if</span> (matrix[0][0] === 0) {
        <span class="keyword">for</span> (<span class="keyword">let</span> r = 0; r < R; r++) matrix[r][0] = 0;
    }

    <span class="comment">// 4. Fix First Row</span>
    <span class="keyword">if</span> (firstRowZero) {
        <span class="keyword">for</span> (<span class="keyword">let</span> c = 0; c < C; c++) matrix[0][c] = 0;
    }
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            67. Spiral Matrix
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Onion Peeling"</div>
            <div class="eli5-box">
                <p>You want to list numbers in a spiral order.</p>
                <p>Imagine 4 walls shrinking in on you:</p>
                <ul>
                    <li><strong>Top Wall</strong> (Start Row)</li>
                    <li><strong>Right Wall</strong> (End Col)</li>
                    <li><strong>Bottom Wall</strong> (End Row)</li>
                    <li><strong>Left Wall</strong> (Start Col)</li>
                </ul>
                <p>1. Walk Left->Right (along Top). Push Top wall down.<br>
                2. Walk Top->Bottom (along Right). Push Right wall left.<br>
                3. Walk Right->Left (along Bottom). Push Bottom wall up.<br>
                4. Walk Bottom->Top (along Left). Push Left wall right.<br>
                Repeat until walls crash.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Boundary Simulation</strong><br>
                Maintain `top, bottom, left, right`.<br>
                While `left <= right` and `top <= bottom`, loop 4 directions.<br>
                *Crucial check:* After moving Top or Right, check if boundaries crossed *before* doing the reverse walks (Bottom/Left).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">spiralOrder</span>(<span class="var">matrix</span>: number[][]): number[] {
    <span class="keyword">const</span> res: number[] = [];
    <span class="keyword">let</span> left = 0, right = matrix[0].length - 1;
    <span class="keyword">let</span> top = 0, bottom = matrix.length - 1;

    <span class="keyword">while</span> (left <= right && top <= bottom) {
        <span class="comment">// 1. Top Row (Left -> Right)</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i <= right; i++) res.push(matrix[top][i]);
        top++;

        <span class="comment">// 2. Right Col (Top -> Bottom)</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = top; i <= bottom; i++) res.push(matrix[i][right]);
        right--;

        <span class="comment">// Check exit condition</span>
        <span class="keyword">if</span> (left > right || top > bottom) <span class="keyword">break</span>;

        <span class="comment">// 3. Bottom Row (Right -> Left)</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i >= left; i--) res.push(matrix[bottom][i]);
        bottom--;

        <span class="comment">// 4. Left Col (Bottom -> Top)</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom; i >= top; i--) res.push(matrix[i][left]);
        left++;
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            68. Number of 1 Bits (Hamming Weight)
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Light Bulbs"</div>
            <div class="eli5-box">
                <p>A number is stored as binary (light bulbs). <code>11</code> is <code>1011</code> (3 bulbs on).</p>
                <p>We want to count the lit bulbs.</p>
                <p><strong>Slow Way:</strong> Check last bulb. Shift right. Check next bulb. Shift right. (32 checks).</p>
                <p><strong>Magic Way (n & n-1):</strong> This weird math trick turns off the <em>rightmost</em> lit bulb instantly.</p>
                <p>Example: <code>1011 & 1010 = 1010</code> (Last 1 gone).<br>
                <code>1010 & 1001 = 1000</code> (Next 1 gone).<br>
                We only loop as many times as there are 1s.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Bit Manipulation (Kernighan's Algorithm)</strong><br>
                <code>n = n & (n - 1)</code> removes the least significant bit (LSB).<br>
                Loop while n > 0.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">hammingWeight</span>(<span class="var">n</span>: number): number {
    <span class="keyword">let</span> count = 0;
    <span class="keyword">while</span> (n !== 0) {
        n = n & (n - 1); <span class="comment">// Remove rightmost 1</span>
        count++;
    }
    <span class="keyword">return</span> count;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            69. Counting Bits
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Copycat"</div>
            <div class="eli5-box">
                <p>We want to count bits for 0, 1, 2, 3, 4, 5... all the way to N.</p>
                <p>Calculating each one from scratch is slow.</p>
                <p><strong>Notice the pattern:</strong></p>
                <ul>
                    <li>Number <strong>2</strong> (10) looks like <strong>1</strong> (1), just shifted. Same number of 1s.</li>
                    <li>Number <strong>4</strong> (100) looks like <strong>2</strong> (10), just shifted. Same number of 1s.</li>
                    <li>Number <strong>3</strong> (11) looks like <strong>1</strong> (1) shifted, plus an extra 1 at the end.</li>
                </ul>
                <p>Formula: <code>Bits(i) = Bits(i / 2) + (is i odd?)</code></p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Dynamic Programming + Bit Shift</strong><br>
                <code>dp[i] = dp[i >> 1] + (i & 1)</code>.<br>
                We reuse the count from `i / 2` (which we already calculated).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">countBits</span>(<span class="var">n</span>: number): number[] {
    <span class="keyword">const</span> dp = <span class="keyword">new</span> Array(n + 1).fill(0);

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i <= n; i++) {
        <span class="comment">// i >> 1 is "i divided by 2"</span>
        <span class="comment">// i & 1 is "is last digit 1?" (odd check)</span>
        dp[i] = dp[i >> 1] + (i & 1);
    }
    <span class="keyword">return</span> dp;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            70. Reverse Bits
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Mirror"</div>
            <div class="eli5-box">
                <p>You have a 32-bit number. You want to flip it horizontally.</p>
                <p>Input: <code>000...011</code> (3)</p>
                <p>Output: <code>110...000</code> (Huge number)</p>
                <p><strong>Strategy:</strong> Take the last bit of Input. Add it to Result. <br>
                Then, Shift Input to Right (delete used bit).<br>
                Shift Result to Left (make room for new bit).</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Bitwise Shift Accumulation</strong><br>
                Loop 32 times.<br>
                1. <code>res = res << 1</code> (Shift result left to open spot).<br>
                2. <code>bit = n & 1</code> (Get last bit of n).<br>
                3. <code>res = res | bit</code> (Add bit to result).<br>
                4. <code>n = n >> 1</code> (Shift n right to process next).
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">reverseBits</span>(<span class="var">n</span>: number): number {
    <span class="keyword">let</span> res = 0;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < 32; i++) {
        <span class="comment">// Make room in Result</span>
        res = res << 1;
        
        <span class="comment">// Add the last bit of n to Result</span>
        res = res | (n & 1);
        
        <span class="comment">// Remove used bit from n</span>
        n = n >>> 1; <span class="comment">// Use >>> for unsigned shift in JS/TS</span>
    }
    <span class="comment">// Convert to unsigned integer logic in JS</span>
    <span class="keyword">return</span> res >>> 0;
}</pre>
        </div>
    </div>
    <div class="problem-card">
        <div class="header">
            71. Missing Number
            <span class="difficulty">Easy</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Sum Trick"</div>
            <div class="eli5-box">
                <p>You have cards numbered 0, 1, 2, 3. One is missing.</p>
                <p><strong>Method A (Math):</strong> You know that 0+1+2+3 = 6. <br>
                You sum up the cards you actually have: 0+1+3 = 4.<br>
                Difference: 6 - 4 = 2. That's the missing one!</p>
                <p><strong>Method B (XOR):</strong> XOR is like a magic cancellation. <br>
                If you XOR the <em>expected</em> list (0,1,2,3) with the <em>actual</em> list (0,1,3), the duplicates cancel out (become 0). The only thing left standing is the number that appeared once (the missing one).</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Math (Gauss Sum) or XOR</strong><br>
                Math: <code>TargetSum = n * (n + 1) / 2</code>. Result = Target - ActualSum.<br>
                XOR: <code>res = res ^ i ^ nums[i]</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">missingNumber</span>(<span class="var">nums</span>: number[]): number {
    <span class="keyword">const</span> n = nums.length;
    <span class="comment">// Expected sum of 0..n</span>
    <span class="keyword">const</span> expectedSum = (n * (n + 1)) / 2;
    
    <span class="keyword">const</span> actualSum = nums.reduce((acc, val) => acc + val, 0);
    
    <span class="keyword">return</span> expectedSum - actualSum;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            72. Sum of Two Integers
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Alien Calculator"</div>
            <div class="eli5-box">
                <p>You are banned from using the <code>+</code> button.</p>
                <p>How does a computer actually add? Two steps:</p>
                <ol>
                    <li><strong>XOR (^):</strong> Adds digits but forgets to carry. (1 + 1 becomes 0). This is the "Sum without carry".</li>
                    <li><strong>AND (&):</strong> Finds where the carry should happen. (1 + 1 generates a carry). Then we shift it left (<< 1) to apply it to the next column.</li>
                </ol>
                <p>Repeat until there is nothing left to carry.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Full Adder Logic</strong><br>
                <code>a ^ b</code> = Sum without carry.<br>
                <code>(a & b) << 1</code> = Carry.<br>
                Loop until carry is 0.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">getSum</span>(<span class="var">a</span>: number, <span class="var">b</span>: number): number {
    <span class="keyword">while</span> (b !== 0) {
        <span class="comment">// 1. Calculate Carry</span>
        <span class="keyword">const</span> carry = (a & b) << 1;
        
        <span class="comment">// 2. Calculate Sum (without carry)</span>
        a = a ^ b;
        
        <span class="comment">// 3. Carry becomes the new 'b' to add next round</span>
        b = carry;
    }
    <span class="keyword">return</span> a;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            73. Palindromic Substrings
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Ripple Effect"</div>
            <div class="eli5-box">
                <p>String: "aaa". How many palindromes?</p>
                <p>Instead of checking every possible start and end (slow), treat every letter as the <strong>Center</strong> of a splash.</p>
                <p>Throw a rock at index 1 ('a').<br>
                - Ripple size 0: "a" (Yes).<br>
                - Ripple size 1: "aaa" (Yes).<br>
                - Ripple size 2: Bounds check fail.</p>
                <p><strong>Trap:</strong> Don't forget "Even" centers! Throw a rock <em>between</em> letters (like between index 0 and 1) to find "aa".</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Center Expansion</strong><br>
                Iterate <code>i</code> from 0 to N.<br>
                1. Expand Odd: <code>l=i, r=i</code>.<br>
                2. Expand Even: <code>l=i, r=i+1</code>.<br>
                Count++ while <code>s[l] == s[r]</code>.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">countSubstrings</span>(<span class="var">s</span>: string): number {
    <span class="keyword">let</span> count = 0;

    <span class="keyword">function</span> countPals(l: number, r: number) {
        <span class="keyword">while</span> (l >= 0 && r < s.length && s[l] === s[r]) {
            count++;
            l--;
            r++;
        }
    }

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < s.length; i++) {
        countPals(i, i);     <span class="comment">// Odd Length</span>
        countPals(i, i + 1); <span class="comment">// Even Length</span>
    }

    <span class="keyword">return</span> count;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            74. Longest Palindromic Substring
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "King of Ripples"</div>
            <div class="eli5-box">
                <p>Exactly the same as Question 73, but instead of counting <em>how many</em> ripples, we just want to remember the <em>widest</em> ripple we ever saw.</p>
                <p>We keep a notebook: "Best so far: 'aba' (length 3)".<br>
                If we find a ripple of length 5, we erase the old note and write the new one.</p>
            </div>

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Center Expansion</strong><br>
                Same logic. Track `resLen` and `resStart`.<br>
                Update max if `(r - l + 1) > resLen`.
            </div>

            <pre>
<span class="keyword">function</span> <span class="func">longestPalindrome</span>(<span class="var">s</span>: string): string {
    <span class="keyword">let</span> res = "";
    <span class="keyword">let</span> resLen = 0;

    <span class="keyword">function</span> check(l: number, r: number) {
        <span class="keyword">while</span> (l >= 0 && r < s.length && s[l] === s[r]) {
            <span class="keyword">if</span> (r - l + 1 > resLen) {
                resLen = r - l + 1;
                res = s.substring(l, r + 1);
            }
            l--;
            r++;
        }
    }

    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < s.length; i++) {
        check(i, i);     <span class="comment">// Odd</span>
        check(i, i + 1); <span class="comment">// Even</span>
    }
    <span class="keyword">return</span> res;
}</pre>
        </div>
    </div>

    <div class="problem-card">
        <div class="header">
            75. Detect Squares
            <span class="difficulty">Medium</span>
        </div>
        <div class="content">
            
            <div class="section-title">ðŸ‘¶ ELI5: The "Connect the Dots"</div>
            <div class="eli5-box">
                <p>You are given a point (Query Point). You want to know how many squares you can form using this point and existing points.</p>
                <p>A Square needs 4 points.</p>
                <p><strong>Strategy:</strong> Don't look for 3 other points (Too hard). Look for <strong>Diagonals</strong>.</p>
                <p>1. Assume the Query Point is one corner.<br>
                2. Iterate through your list of existing points. Treat each one as the <strong>Opposite Diagonal Corner</strong>.<br>
                3. If (Query, Existing) forms a valid diagonal (meaning `|dx| == |dy|` and size > 0), then you magically know EXACTLY where the other two corners <em>must</em> be.</p>
                <p>4. Just check if those two "Must Be" corners exist in your list.</p>
            </div>
            

            <div class="section-title">ðŸ§  The Developer Logic</div>
            <div class="pattern-box">
                <strong>Pattern: Hash Map Geometry</strong><br>
                Store points in a frequency map <code>Map&lt;"x,y", count&gt;</code> (since duplicates are allowed).<br>
                For `count(qx, qy)`, iterate all `(px, py)` in storage.<br>
                Condition: `Math.abs(qx - px) === Math.abs(qy - py)` and `qx != px`.<br>
                Result += `count(px, py) * count(qx, py) * count(px, qy)`.
            </div>

            <pre>
<span class="keyword">class</span> DetectSquares {
    pointCount: Map&lt;string, number&gt;;
    points: number[][];

    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.pointCount = <span class="keyword">new</span> Map();
        <span class="keyword">this</span>.points = [];
    }

    <span class="func">add</span>(<span class="var">point</span>: number[]): void {
        <span class="keyword">const</span> key = point.join(',');
        <span class="keyword">this</span>.pointCount.set(key, (<span class="keyword">this</span>.pointCount.get(key) || 0) + 1);
        <span class="keyword">this</span>.points.push(point);
    }

    <span class="func">count</span>(<span class="var">point</span>: number[]): number {
        <span class="keyword">let</span> res = 0;
        <span class="keyword">const</span> [qx, qy] = point;

        <span class="keyword">for</span> (<span class="keyword">const</span> [px, py] <span class="keyword">of</span> <span class="keyword">this</span>.points) {
            <span class="comment">// 1. Check if it's a valid diagonal</span>
            <span class="comment">// (Must be a square, so |dx| must equal |dy|, and size > 0)</span>
            <span class="keyword">if</span> (Math.abs(qx - px) !== Math.abs(qy - py) || qx === px) {
                <span class="keyword">continue</span>;
            }

            <span class="comment">// 2. If diagonal exists, the other two corners are fixed:</span>
            <span class="comment">// Corner 1: (qx, py)</span>
            <span class="comment">// Corner 2: (px, qy)</span>
            <span class="keyword">const</span> corner1 = <span class="keyword">this</span>.pointCount.get(`${qx},${py}`) || 0;
            <span class="keyword">const</span> corner2 = <span class="keyword">this</span>.pointCount.get(`${px},${qy}`) || 0;

            res += corner1 * corner2;
        }
        <span class="keyword">return</span> res;
    }
}</pre>
        </div>
    </div>
</body>
</html>